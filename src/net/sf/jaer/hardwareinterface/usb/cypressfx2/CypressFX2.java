/*
 * USBAEMon.java
 *
 * Created on February 17, 2005, 7:54 AM
 */
package net.sf.jaer.hardwareinterface.usb.cypressfx2;

import java.awt.Component;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeSupport;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.prefs.Preferences;

import javax.swing.ProgressMonitor;

import net.sf.jaer.aemonitor.AEListener;
import net.sf.jaer.aemonitor.AEMonitorInterface;
import net.sf.jaer.aemonitor.AEPacketRaw;
import net.sf.jaer.aemonitor.AEPacketRawPool;
import net.sf.jaer.chip.AEChip;
import net.sf.jaer.event.EventPacket;
//import ch.unizh.ini.caviar.chip.EventExtractor2D;
import net.sf.jaer.eventprocessing.EventFilter;
import net.sf.jaer.eventprocessing.FilterChain;
import net.sf.jaer.hardwareinterface.BlankDeviceException;
import net.sf.jaer.hardwareinterface.HardwareInterfaceException;
import net.sf.jaer.hardwareinterface.usb.ReaderBufferControl;
import net.sf.jaer.hardwareinterface.usb.USBInterface;
import net.sf.jaer.stereopsis.StereoPairHardwareInterface;
import net.sf.jaer.util.HexFileParser;
import net.sf.jaer.util.HexString;
import de.thesycon.usbio.PnPNotify;
import de.thesycon.usbio.PnPNotifyInterface;
import de.thesycon.usbio.UsbIo;
import de.thesycon.usbio.UsbIoBuf;
import de.thesycon.usbio.UsbIoErrorCodes;
import de.thesycon.usbio.UsbIoInterface;
import de.thesycon.usbio.UsbIoPipe;
import de.thesycon.usbio.UsbIoReader;
import de.thesycon.usbio.structs.USBIO_CLASS_OR_VENDOR_REQUEST;
import de.thesycon.usbio.structs.USBIO_CONFIGURATION_INFO;
import de.thesycon.usbio.structs.USBIO_DATA_BUFFER;
import de.thesycon.usbio.structs.USBIO_PIPE_PARAMETERS;
import de.thesycon.usbio.structs.USBIO_SET_CONFIGURATION;
import de.thesycon.usbio.structs.USB_DEVICE_DESCRIPTOR;
import de.thesycon.usbio.structs.USB_STRING_DESCRIPTOR;
import net.sf.jaer.hardwareinterface.usb.HasUsbStatistics;
import net.sf.jaer.hardwareinterface.usb.USBPacketStatistics;

/**
 * Devices that use the CypressFX2 and the USBIO driver, e.g. the DVS retinas,
 * the USBAERmini2. This class should not normally be constructed but rather a
 * subclass that overrides the AEReader should be used.
 * <p>
 * In this class, you can also set the size of the host buffer with
 * {@link #setAEBufferSize}, giving you more time between calls to process the
 * events.
 * <p>
 * On the device, a timer sends all available events approximately every 10ms --
 * you don't need to wait for a fixed size buffer to be captured to be available
 * to the host. But if events come quickly enough, new events can be available
 * much faster than this.
 * <p>
 * You can also request at any time an early transfer of events with
 * {@link #requestEarlyTransfer}. This will send a vendor request to the device
 * to immediately transfer available events, but they won't be available to the
 * host for a little while, depending on USBIOInterface and driver latency.
 * <p>
 * See the main() method for an example of use.
 * <p>
 * Fires PropertyChangeEvent on the following
 * <ul>
 * <li> NEW_EVENTS_PROPERTY_CHANGE - on new events from driver
 * <li> "readerStarted" - when the reader thread is started
 * </ul>
 *
 *
 * @author tobi delbruck/raphael berner
 */
public class CypressFX2 implements UsbIoErrorCodes, PnPNotifyInterface, AEMonitorInterface, ReaderBufferControl, USBInterface, HasUsbStatistics {

    /**
     * Used to store preferences, e.g. buffer sizes and number of buffers.
     */
    protected static Preferences prefs = Preferences.userNodeForPackage(CypressFX2.class);

    protected static final Logger log = Logger.getLogger("net.sf.jaer");
    protected AEChip chip;
    // A .bix file format is needed for RAM download.
    // The binary file format .iic (i2c) format are image files for the EEPROM. IIC files will not
    // correctly download to RAM. Therefore they cannot be used to bootstrap a blank device.
    // The bootstrap code is necessary in order to write the Cypress EEPROM.
    // An Intel  .hex file should also be OK for RAM download but it does not include the device descriptor TODO could be wrong
    /**
     * filename of FX2 binary executable, generated by uVision project and
     * associated script that runs hex2bix
     */
    public final static String FIRMWARE_FILENAME_TMPDIFF128_BIX = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAER_FX2LP_Retina.bix"; //"USBAEMonFirware.bin";
    /**
     * filename of FX2 binary executable, generated by uVision project and
     * associated script that runs hex2bix
     */
    public final static String FIRMWARE_FILENAME_TMPDIFF128_HEX = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAER_FX2LP_Retina.hex"; //"USBAEMonFirware.bin";
    /**
     * filename of FX2 binary executable, generated by uVision project and
     * associated script that runs hex2bix
     */
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERmini2.bix";
    /**
     * filename of FX2 binary executable, generated by uVision project and
     * associated script that runs hex2bix
     */
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERmini2.hex";
    /**
     * filename of FX2 binary executable, generated by uVision project and
     * associated script that runs hex2bix
     */
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_IIC = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERmini2.iic";
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_JTAG_IIC = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERmini2_JTAG.iic";
    public final static String FIRMWARE_FILENAME_MAPPER_IIC = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USB2AERmapper.iic";
    public final static String FIRMWARE_FILENAME_STEREO_IIC = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/TMPdiffStereo.iic";//    public final static String FIRMWARE_FILENAME_TCVS320_IIC="/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERTCVS320.iic";
    public final static String FIRMWARE_FILENAME_TCVS320_HEX = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERTCVS320.hex";
    public final static String FIRMWARE_FILENAME_TCVS320_BIX = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERTCVS320.bix";
    public final static String FIRMWARE_FILENAME_DVS128_IIC = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/firmwareFX2_DVS128.iic";
    public final static String FIRMWARE_FILENAME_COCHLEAAMS_BIX = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/firmwareFX2_Cochleaams1b.bix";
    /**
     * Driver GUID (Globally unique ID, for this USB driver instance. This GUID
     * is how this class of USBIO devices is enumerated by the factory.
     */
    public final static String GUID = "{7794C79A-40A7-4A6C-8A29-DA141C20D78C}"; // see guid.txt at root of CypressFX2USB2, generated by tobi for CypressFX2RetinaBiasgen
    /**
     * A blank Cypress FX2 has VID/PID of 0x04b4/0x8613. This VID/PID pair is
     * used to indicate a blank device that needs programming.
     */
    static final public short VID_BLANK = (short) 0x04b4, PID_BLANK = (short) 0x8613;
    /**
     * All the devices here have vendor ID VID which has been allocated to jAER
     * by Thesycon
     */
    static public final short VID = USBInterface.VID_THESYCON;
    static public final short PID_DVS128_REV0 = (short) 0x8400;
    /**
     * For CochleaAMS devices
     */
    static public final short PID_COCHLEAAMS = (short) 0x8405;
    static public final short PID_TMPDIFF128_RETINA = (short) 0x8700;
    //static public final short PID_TMPDIFF128_FX2_SMALL_BOARD=(short)0x8701; not used anymore, replace with new VID/PID from thesycon
    static public final short PID_USBAERmini2 = (short) 0x8801;
    static public final short PID_USBAERmini2_without_firmware = (short) 0x8800;
    static public final short PID_USB2AERmapper = (short) 0x8900;
    static public final short DID_STEREOBOARD = (short) 0x2007;
    static public final short PID_TCVS320_RETINA = (short) 0x8702;
    /**
     * event supplied to listeners when new events are collected. this is final
     * because it is just a marker for the listeners that new events are
     * available
     */
    public final PropertyChangeEvent NEW_EVENTS_PROPERTY_CHANGE = new PropertyChangeEvent(this, "NewEvents", null, null);

    /**
     * Property change fired when new events are received. The new object in the
     * event is AEPacketRaw just received.
     */
    public static final String PROPERTY_CHANGE_NEW_EVENTS = "NewEvents";

    /**
     * Property change fired when a new message is received on the asynchronous
     * status endpoint.
     *
     * @see AsyncStatusThread
     */
    public static final String PROPERTY_CHANGE_ASYNC_STATUS_MSG = "AsyncStatusMessage";

    /**
     * Status messages sent by device. This header byte identifies the message
     * type.
     */
    public static final byte STATUS_MSG_TIMESTAMPS_RESET = (byte) 1, STATUS_MSG_OTHER = (byte) 0xff;

    /**
     * This support can be used to register this interface for property change
     * events
     */
    public PropertyChangeSupport support = new PropertyChangeSupport(this);    // consts
    final static byte AE_MONITOR_ENDPOINT_ADDRESS = (byte) 0x86;  // this is endpoint of AE fifo on Cypress FX2, 0x86 means IN endpoint EP6.
    final static byte STATUS_ENDPOINT_ADDRESS = (byte) 0x81;  // this is endpoint 1 IN for device to report status changes asynchronously
    final short CPUCS = (short) 0xE600;            // address of the CPUCS register, using for resetting 8051 and downloading firmware
    // vendor requests.
    public final static byte VENDOR_REQUEST_START_TRANSFER = (byte) 0xb3; // this is request to start sending events from FIFO endpoint
    public final static byte VENDOR_REQUEST_STOP_TRANSFER = (byte) 0xb4; // this is request to stop sending events from FIFO endpoint
    public final static byte VENDOR_REQUEST_EARLY_TRANFER = (byte) 0xb7; // this is request to transfer whatever you have now
    public static final byte VENDOR_REQUEST_SEND_BIAS_BYTES = (byte) 0xb8; // vendor command to send bias bytes out on SPI interface
    public final byte VENDOR_REQUEST_POWERDOWN = (byte) 0xb9; // vendor command to send bias bytes out on SPI interface
    public final byte VENDOR_REQUEST_FLASH_BIASES = (byte) 0xba;  // vendor command to flash the bias values to EEPROM
    public final byte VENDOR_REQUEST_RESET_TIMESTAMPS = (byte) 0xbb; // vendor command to reset timestamps
    public final byte VENDOR_REQUEST_SET_ARRAY_RESET = (byte) 0xbc; // vendor command to set array reset of retina
    public final byte VENDOR_REQUEST_DO_ARRAY_RESET = (byte) 0xbd; // vendor command to do an array reset (toggle arrayReset for a fixed time)
    public final byte VENDOR_REQUEST_SET_SYNC_ENABLED = (byte) 0xbe;  // vendor command to set whether sync input generates sync events
    //final byte VENDOR_REQUEST_WRITE_EEPROM=(byte)0xbe; // vendor command to write EEPROM
    public final byte VENDOR_REQUEST_SET_LED = (byte) 0xbf; // vendor command to set the board's LED
    public static final byte VR_DOWNLOAD_FIRMWARE = (byte) 0xC5;  // vendor request to program CPLD or FPGA
    public static final byte VR_SET_DEVICE_NAME = (byte) 0xC2;  // set serial number string

    public static final byte VENDOR_REQUEST_WRITE_CPLD_SR = (byte) 0xCF;  // write CPLD shift register (configuration data); also stops ADC if running
    public static final byte VENDOR_REQUEST_RUN_ADC = (byte) 0xCE;  // start and stop aquisition of ADC data
    //final byte VENDOR_REQUEST_READ_EEPROM=(byte)0xca; // vendor command to write EEPROM
    // #define VR_EEPROM		0xa2 // loads (uploads) EEPROM
    public final byte VR_EEPROM = (byte) 0xa2;
    // #define	VR_RAM			0xa3 // loads (uploads) external ram
    public final byte VR_RAM = (byte) 0xa3;    // this is special hw vendor request for reading and writing RAM, used for firmware download
    public static final byte VENDOR_REQUEST_FIRMWARE = (byte) 0xA0; // download/upload firmware -- builtin FX2 feature
    protected final static short CONFIG_INDEX = 0;
    protected final static short CONFIG_NB_OF_INTERFACES = 1;
    protected final static short CONFIG_INTERFACE = 0;
    protected final static short CONFIG_ALT_SETTING = 0;
    protected final static int CONFIG_TRAN_SIZE = 512;
    // following are to support realtime filtering
    // the AEPacketRaw is used only within this class. Each packet is extracted using the chip extractor object from the first filter in the
    // realTimeFilterChain to a reused EventPacket.
    AEPacketRaw realTimeRawPacket = null; // used to hold raw events that are extracted for real time procesing
    EventPacket realTimePacket = null; // used to hold extracted real time events for processing
    /**
     * start of events that have been captured but not yet processed by the
     * realTimeFilters
     */
    private int realTimeEventCounterStart = 0;
    /**
     * timeout in ms to reopen driver (reloading firmware) if no events are
     * received for this time. This timeout will restart AE transmission if
     * another process (e.g. Biasgen) reloads the firmware. This timer is
     * checked on every attempt to acquire events.
     */
    public static long NO_AE_REOPEN_TIMEOUT = 3000;
    /**
     * Time in us of each timestamp count here on host, could be different on
     * board.
     */
    public final short TICK_US = 1;
    short TICK_US_BOARD = 10; // time in us of timestamp tick on USB board. raphael: should not be final, i need to overwrite it and set it to 1
    /**
     * default size of AE buffer for user processes. This is the buffer that is
     * written by the hardware capture thread that holds events that have not
     * yet been transferred via {@link #acquireAvailableEventsFromDriver} to
     * another thread
     *
     * @see #acquireAvailableEventsFromDriver
     * @see AEReader
     * @see #setAEBufferSize
     */
    public static final int AE_BUFFER_SIZE = 100000; // should handle 5Meps at 30FPS
    /**
     * this is the size of the AEPacketRaw that are part of AEPacketRawPool that
     * double buffer the translated events between rendering and capture threads
     */
    protected int aeBufferSize = prefs.getInt("CypressFX2.aeBufferSize", AE_BUFFER_SIZE);
    /**
     * the event reader - a buffer pool thread from USBIO subclassing
     */
    protected AEReader aeReader = null;
    /**
     * the thread that reads device status messages on EP1
     */
    protected AsyncStatusThread asyncStatusThread = null;
    /**
     * a USBIO buffer used for calls
     */
    protected UsbIoBuf BufDesc = null;
    /**
     * The pool of raw AE packets, used for data transfer
     */
    protected AEPacketRawPool aePacketRawPool = new AEPacketRawPool(this);
    private String stringDescription = "CypressFX2"; // default which is modified by opening

    private USBPacketStatistics usbPacketStatistics = new USBPacketStatistics();

    /**
     * Populates the device descriptor and the string descriptors and builds the
     * String for toString().
     *
     * @param gUsbIo the handle to the UsbIo object.
     */
    protected void populateDescriptors(UsbIo gUsbIo) {
        try {
            int status;
            // getString device descriptor
            status = gUsbIo.getDeviceDescriptor(deviceDescriptor);
            if (status != USBIO_ERR_SUCCESS) {
                UsbIo.destroyDeviceList(gDevList);
                throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getDeviceDescriptor: " + UsbIo.errorText(status));
            } else {
//            log.info("getDeviceDescriptor: Vendor ID (VID) "
//                    + HexString.toString((short)deviceDescriptor.idVendor)
//                    + " Product ID (PID) " + HexString.toString((short)deviceDescriptor.idProduct));
            }

            if (deviceDescriptor.iSerialNumber != 0) {
                this.numberOfStringDescriptors = 3;        // getString string descriptor
            } else {
                numberOfStringDescriptors = 2;
            }
            status = gUsbIo.getStringDescriptor(stringDescriptor1, (byte) 1, 0);
            if (status != USBIO_ERR_SUCCESS) {
                UsbIo.destroyDeviceList(gDevList);
                throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: " + UsbIo.errorText(status));
            } else {
//            log.info("getStringDescriptor 1: " + stringDescriptor1.Str);
            }

            // getString string descriptor
            status = gUsbIo.getStringDescriptor(stringDescriptor2, (byte) 2, 0);
            if (status != USBIO_ERR_SUCCESS) {
                UsbIo.destroyDeviceList(gDevList);
                throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: " + UsbIo.errorText(status));
            } else {
//            log.info("getStringDescriptor 2: " + stringDescriptor2.Str);
            }

            if (this.numberOfStringDescriptors == 3) {
                // getString serial number string descriptor
                status = gUsbIo.getStringDescriptor(stringDescriptor3, (byte) 3, 0);
                if (status != USBIO_ERR_SUCCESS) {
                    UsbIo.destroyDeviceList(gDevList);
                    throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: " + UsbIo.errorText(status));
                } else {
//                log.info("getStringDescriptor 3: " + stringDescriptor3.Str);
                }
            }

            // build toString string
            if (this.numberOfStringDescriptors == 3) {
                stringDescription = (getStringDescriptors()[1] + " " + getStringDescriptors()[2]);
            } else if (this.numberOfStringDescriptors == 2) {
                stringDescription = (getStringDescriptors()[1] + ": Interface " + getInterfaceNumber());
            }
        } catch (BlankDeviceException bd) {
            stringDescription = "Blank Cypress FX2 : Interface " + getInterfaceNumber();
        } catch (Exception e) {
//            e.printStackTrace();
            stringDescription = (getClass().getSimpleName() + ": Interface " + getInterfaceNumber());
        }
//        log.log(Level.INFO, "stringDescription={0}", stringDescription);
    }
    /**
     * The count of events acquired but not yet passed to user via
     * acquireAvailableEventsFromDriver
     */
    protected int eventCounter = 0;  // counts events acquired but not yet passed to user
    /**
     * the last events from {@link #acquireAvailableEventsFromDriver}, This
     * packet is reused.
     */
    protected AEPacketRaw lastEventsAcquired = new AEPacketRaw();
    PnPNotify pnp = null;
    protected boolean inEndpointEnabled = false;  // raphael: changed from private to protected, because i need to access this member
    /**
     * device open status
     */
    protected boolean isOpened = false;
    private boolean aeReaderRunning = false;
    /**
     * the device number, out of all potential compatible devices that could be
     * opened
     */
    protected int interfaceNumber = 0;

    /**
     * This constructor is protected because these instances should be
     * constructed by the CypressFX2Factory. Creates a new instance of
     * USBAEMonitor. Note that it is possible to construct several instances and
     * use each of them to open and read from the same device.
     *
     * @param devNumber the desired device number, in range returned by
     * CypressFX2Factory.getNumInterfacesAvailable
     */
    protected CypressFX2(int devNumber) {
        this.interfaceNumber = devNumber;
//        pnp=new PnPNotify(this);
//        pnp.enablePnPNotification(GUID);
    }

    /**
     * returns the device interface number. This is the index of this device as
     * returned by the interface factory.
     *
     * @return interface number, 0 based
     */
    protected int getInterfaceNumber() {
        return interfaceNumber;
    }

    /**
     * sets the device number to open, according to the order in the hardware
     * interface factory.
     *
     * @param interfaceNumber 0 based interface number
     */
    protected void setInterfaceNumber(int interfaceNumber) {
        this.interfaceNumber = interfaceNumber;
    }

    /**
     * acquire a device for exclusive use, other processes can't open the device
     * anymore used for example for continuous sequencing in matlab
     */
    public void acquireDevice() throws HardwareInterfaceException {
        log.log(Level.INFO, "{0} acquiring device for exclusive access", this);
        int status = gUsbIo.acquireDevice();
        if (status != 0) {
            throw new HardwareInterfaceException("Unable to acquire device for exclusive use: " + UsbIo.errorText(status));
        }
    }

    /**
     * release the device from exclusive use
     */
    public void releaseDevice() throws HardwareInterfaceException {
        log.log(Level.INFO, "{0} releasing device", this);
        int status = gUsbIo.releaseDevice();
        if (status != 0) {
            throw new HardwareInterfaceException("Unable to release device from exclusive use: " + UsbIo.errorText(status));
        }
    }

    /**
     * Returns the PropertyChangeSupport.
     *
     * @return the support.
     * @see #PROPERTY_CHANGE_ASYNC_STATUS_MSG
     * @see #PROPERTY_CHANGE_NEW_EVENTS
     */
    public PropertyChangeSupport getSupport() {
        return this.support;
    }

    /**
     * Returns string description of device including the USB vendor/project
     * IDs. If the device has not been opened then it is minimally opened to
     * populate the deviceDescriptor and then closed.
     *
     * @return the string description of the device.
     */
    @Override
    public String toString() {
        if (numberOfStringDescriptors == 0) {
            try {
                openUsbIo_minimal(); // populates stringDescription and sets numberOfStringDescriptors!=0
            } catch (HardwareInterfaceException e) {
            }
        }
        return stringDescription;
    }

    /**
     * Writes the serial number string to the device EEPROM
     *
     * @param name the string. This string has very limited length, e.g. 4
     * bytes.
     * @throws net.sf.jaer.hardwareinterface.HardwareInterfaceException
     */
    public void setSerialNumber(String name) throws HardwareInterfaceException {
        if (!isOpen()) {
            open();
        }

        USBIO_DATA_BUFFER dataBuffer;

        dataBuffer = new USBIO_DATA_BUFFER(name.length());

        // copy the characters to the databuffer
        for (int i = 0; i < name.length(); i++) {
            dataBuffer.Buffer()[i] = (byte) name.charAt(i);
        }

        sendVendorRequest(VR_SET_DEVICE_NAME, (short) 0, (short) 0, dataBuffer);
        sendVendorRequest(VR_SET_DEVICE_NAME, (short) 0, (short) 0, dataBuffer);

        int status = gUsbIo.getStringDescriptor(stringDescriptor3, (byte) 3, 0); // check if the new name is really set
        if (status != USBIO_ERR_SUCCESS) {
            log.warning("Could not get new device name, Error: " + UsbIo.errorText(status));
        } else {
            //log.fine("Device name set to: " + stringDescriptor3.Str);
            log.info("New Devicename set, close and reopen the device to see the change");
        }
    }
    /**
     * the size in bytes of the EEPROM atttached to the CypressFX2LP
     */
    public int EEPROM_SIZE = 0x8000;//32k;
    /**
     * size of control transfer data packets. Actually vendor request allows for
     * larger data buffer, but windows limits largest xfer to 4096. Here we
     * limit largest to size of buffer for control xfers.
     */
    public final int MAX_CONTROL_XFER_SIZE = 64; // max control xfer size

    /**
     * Returns a new ProgressMonitor with the AEViewer of this chip as the
     * parent component.
     *
     * @param message message at top of monitor
     * @param start start value
     * @param end value
     * @return the ProgressMonitor
     */
    protected ProgressMonitor makeProgressMonitor(String message, int start, int end) {
        Component c = null;
        if ((getChip() != null) && (getChip().getAeViewer() != null)) {
            c = getChip().getAeViewer();
        }
        return new ProgressMonitor(c, message, "", start, end);

    }

    /**
     * This is a BLOCKING write call to write the Cypress EEPROM. Max number of
     * bytes is defined by {@link #EEPROM_SIZE}. Thread-safe.
     *
     * @param addr the starting address
     * @param bytes the bytes to write
     */
    synchronized public void writeEEPROM(int addr, byte[] bytes) throws HardwareInterfaceException {

        log.info("writing EEPROM to addr=" + addr + " with " + bytes.length + " bytes");

        if (bytes.length > this.EEPROM_SIZE) {
            throw new RuntimeException(bytes.length + " is too many bytes for EEPROM to hold (" + EEPROM_SIZE + ")");
        }
        if ((addr < 0) || ((addr + bytes.length) > EEPROM_SIZE)) {
            throw new RuntimeException(bytes.length + " is too many bytes for EEPROM to hold (" + EEPROM_SIZE + ") starting at address " + addr);
        }
        int result; // result of USBIO operations
        USBIO_DATA_BUFFER dataBuffer = null;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest = null;

        int numChunks, index;

        // make vendor request structure and populate it
        vendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        vendorRequest.Request = VR_EEPROM; // this is EEPROM command, direction of vendor request defines download here

        vendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type = UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient = UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits = 0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Index = 0;

        //send all but last chunk
        vendorRequest.Value = (short) addr;			//address to write to (starting)
        dataBuffer = new USBIO_DATA_BUFFER(MAX_CONTROL_XFER_SIZE);
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        index = 0;
        numChunks = bytes.length / MAX_CONTROL_XFER_SIZE;  // this is number of full chunks to send
        ProgressMonitor progressMonitor = makeProgressMonitor("Writing " + numChunks + " " + MAX_CONTROL_XFER_SIZE + " byte chunks FX2 firmware - do not unplug!", 0, numChunks);
        for (int i = 0; i < numChunks; i++) {
            System.arraycopy(bytes, i * MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, MAX_CONTROL_XFER_SIZE);
            result = gUsbIo.classOrVendorOutRequest(dataBuffer, vendorRequest);
            if (result != USBIO_ERR_SUCCESS) {
                close();
                throw new HardwareInterfaceException("Error on downloading segment number " + i + " of EEPROM write: " + UsbIo.errorText(result));
            }
            vendorRequest.Value += MAX_CONTROL_XFER_SIZE;			//change address of EEPROM write location
            // can't cancel
            if (progressMonitor.isCanceled()) {
                progressMonitor = makeProgressMonitor("Writing FX2 firmware - do not unplug!", 0, numChunks);
                progressMonitor.setMillisToDecideToPopup(0);
            }
            progressMonitor.setProgress(i);
            progressMonitor.setNote(String.format("wrote %d of %d chunks of FX2 firmware", i, numChunks));
        }

        // now send final (short) chunk
        int numBytesLeft = bytes.length % MAX_CONTROL_XFER_SIZE;  // remainder
        if (numBytesLeft > 0) {
            dataBuffer = new USBIO_DATA_BUFFER(numBytesLeft);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
            System.arraycopy(bytes, numChunks * MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, numBytesLeft);

            // send remaining part of firmware
            result = gUsbIo.classOrVendorOutRequest(dataBuffer, vendorRequest);
            if (result != USBIO_ERR_SUCCESS) {
                close();
                throw new HardwareInterfaceException("Error on downloading final segment of EEPROM write: " + UsbIo.errorText(result) + "\nIs there an EEPROM? Does the device have firmware that can write the EEPROM?");
            }
        }
        progressMonitor.close();

    } // writeEEPROM

    /**
     * erases the VID/PID/DID and device identifier strings
     */
    synchronized protected void eraseEEPROM() throws HardwareInterfaceException {
        log.info("erasing EEPROM of size " + (EEPROM_SIZE / 1024) + " kB by writing all zeros to it");
        writeEEPROM(0, new byte[EEPROM_SIZE]);
    }

    /**
     * Read the EEPROM contents.
     *
     * @param addr the starting address
     * @param length the number of bytes to read
     */
    synchronized protected byte[] readEEPROM(int addr, int length) throws HardwareInterfaceException {
        int result;
        if (length > EEPROM_SIZE) {
            throw new RuntimeException(length + " is more bytes than EEPROM can hold (" + EEPROM_SIZE + ")");
        }
        if ((addr < 0) || ((addr + length) > EEPROM_SIZE)) {
            throw new RuntimeException(length + " is too many bytes to read from EEPROM which holds " + EEPROM_SIZE + " bytes, if you start at address " + addr);
        }
        USBIO_DATA_BUFFER dataBuffer = null;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest = null;

        byte[] uploadBuffer = new byte[length];

        // make vendor request structure and populate it
        vendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();
        vendorRequest.Request = VR_EEPROM; // this is download/upload EEPROM command, direction of vendor request defines upload to host

        vendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type = UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient = UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits = 0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Index = 0;

        dataBuffer = new USBIO_DATA_BUFFER(length);
        int bytesTransferred = 0;
        dataBuffer.setNumberOfBytesToTransfer(length);
        vendorRequest.Value = (short) addr; // this is EEPROM addr to read from for this chunk
        result = gUsbIo.classOrVendorInRequest(dataBuffer, vendorRequest);  // IN request defines direction, so will be understood as read EEPROM on device
        if (result != USBIO_ERR_SUCCESS) {
            close();
            throw new HardwareInterfaceException("Error during uploading EEPROM: " + UsbIo.errorText(result));
        }
        if (dataBuffer.getBytesTransferred() != length) {
            throw new HardwareInterfaceException("wrong number of bytes transferred, asked for " + length + ", got " + dataBuffer.getBytesTransferred());
        }
        System.arraycopy(dataBuffer.Buffer(), 0, uploadBuffer, 0, length);

        return uploadBuffer;
    }

    /**
     * writes the Cypress "C0" load to the EEPROM that makes the Cypress FX2
     * have a Vender, Product, and Device ID on powerup.
     *
     * @param VID vendor ID
     * @param PID product ID
     * @param DID the 'device' ID, can be used to individualize devices. This is
     * not the same as the serial number, which by convention is the third
     * string ID.
     */
    synchronized public void writeVIDPIDDID(short VID, short PID, short DID) throws HardwareInterfaceException {
        byte[] b = new byte[8];
        b[0] = (byte) 0xC0;
        b[1] = (byte) (VID & 0xFF);    // vid LSB
        b[2] = (byte) ((VID & 0xFF00) >>> 8); // vid MSB
        b[3] = (byte) (PID & 0xFF);
        b[4] = (byte) ((PID & 0xFF00) >>> 8);
        b[5] = (byte) (DID & 0xFF);
        b[6] = (byte) ((DID & 0xFF00) >>> 8);
        b[7] = (byte) (0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)

        writeEEPROM(0, b);
    }
//    private class WriteC2LoadFromHexFileTask extends SwingWorker{
//
//        protected Object doInBackground() throws Exception {
//        }
//
//    }

    /**
     * writes the Cypress "C2" load to the EEPROM that makes the Cypress have
     * full EEPROM firmware, including VID, PID, DID. On reset the Cypress will
     * load its RAM from the EEPROM.
     *
     * @param firmwareFilename a File containing the binary format .iic file
     * firmware as output from hex2bix. This is a flat firmware format that
     * starts at address 0. It does not include the VID/PID written for the C2
     * load.
     * @param VID vendor ID
     * @param PID product ID
     * @param DID the 'device' ID, can be used to individualize devices
     */
    public void writeC2Load(String firmwareFilename, short VID, short PID, short DID) throws HardwareInterfaceException {
        byte[] fw = null;

        try {
            fw = loadBinaryFirmwareFile(firmwareFilename);
        } catch (IOException e) {
            throw new HardwareInterfaceException(e.getMessage());
        }

        byte[] b = new byte[12];
        b[0] = (byte) 0xC2;
        b[1] = (byte) (VID & 0xFF);    // vid LSB
        b[2] = (byte) ((VID & 0xFF00) >>> 8); // vid MSB
        b[3] = (byte) (PID & 0xFF);
        b[4] = (byte) ((PID & 0xFF00) >>> 8);
        b[5] = (byte) (DID & 0xFF);
        b[6] = (byte) ((DID & 0xFF00) >>> 8);
        b[7] = (byte) (0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)

        b[8] = (byte) ((fw.length & 0xFF00) >>> 8);
        b[9] = (byte) ((fw.length & 0xFF)); // length of firmware in these bytes
        b[10] = 0;
        b[11] = 0;

        byte[] end = new byte[5];
        end[0] = (byte) 0x80;
        end[1] = (byte) 0x01;
        end[2] = (byte) 0xe6;
        end[4] = 0;

        byte[] w = new byte[b.length + fw.length + end.length];
        System.arraycopy(b, 0, w, 0, b.length);
        System.arraycopy(fw, 0, w, b.length, fw.length);
        System.arraycopy(end, 0, w, b.length + fw.length, end.length);

        writeEEPROM(0, w);
    }

    /**
     * writes the Cypress "C2" load to the EEPROM that makes the Cypress have
     * EEPROM firmware, including VID, PID, DID.
     *
     * @param VID
     * @param PID
     * @param DID the 'device' ID, can be used to individualize devices
     * @param hexFileResourcePath a full path pointing to a resource containing
     * the firmware as output from compiler in Intel hex format. This resource
     * is a file that is somewhere in the classpath, i.e. it is a file that is
     * included in the project jar. For example:
     * "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAER_FX2LP_Retina.hex"
     * @see #FIRMWARE_FILENAME_TMPDIFF128_HEX
     * @see #FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX
     */
    synchronized public void writeHexFileToEEPROM(String hexFileResourcePath, short VID, short PID, short DID) throws HardwareInterfaceException {

        log.info("writing retina EEPROM firmware file " + hexFileResourcePath + " with VID=" + HexString.toString(VID) + " PID=" + HexString.toString(PID) + " DID=" + HexString.toString(DID));
        HexFileParser parser;
        try {
            parser = new HexFileParser(hexFileResourcePath);
        } catch (IOException e2) {
            throw new HardwareInterfaceException(e2.getMessage() + ": cannot open resource " + hexFileResourcePath);
        }
        ArrayList<HexFileParser.Record> records = parser.getRecords();
        int index = 0;
        byte[] b;

        log.info("writing " + records.size() + " records");

//        JFrame frame=new JFrame("EEPROM progress");
//        JProgressBar progressBar;
//        progressBar = new JProgressBar(0, records.size());
//        progressBar.setName("EEPROM programming");
//        progressBar.setValue(0);
//        progressBar.setStringPainted(true);
//        frame.getContentPane().appendCopy(progressBar);
//        frame.pack();
//        frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
//        frame.setVisible(true);
        b = new byte[12];
        b[0] = (byte) 0xC2; // write C2 load format header
        b[1] = (byte) (VID & 0xFF);    // vid LSB
        b[2] = (byte) ((VID & 0xFF00) >>> 8); // vid MSB
        b[3] = (byte) (PID & 0xFF);
        b[4] = (byte) ((PID & 0xFF00) >>> 8);
        b[5] = (byte) (DID & 0xFF);
        b[6] = (byte) ((DID & 0xFF00) >>> 8);
        b[7] = (byte) (0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)

        writeEEPROM(0, b); // write VID/PID etc header starting at addr 0

        index += b.length;
        int recNum = 0;
        // now for each hex file record, we must write this record, contiguous with the last one, and each record written to
        // flash must contain the starting address of how many bytes there are (up to 1023) and where the memory should go in the FX2 RAM.
        // now write hex file records, one by one
        for (HexFileParser.Record r : records) {
            b = new byte[4];
            b[0] = (byte) ((r.data.length & 0xFF00) >>> 8);
            b[1] = (byte) ((r.data.length & 0xFF));
            b[2] = (byte) ((r.address & 0xFF00) >>> 8);
            b[3] = (byte) ((r.address & 0xFF));
            writeEEPROM(index, b);
            index += b.length;
            writeEEPROM(index, r.data);
            index += r.data.length;
//            progressBar.setValue(recNum++);
        }

        // now write footer
        b = new byte[5];
        b[0] = (byte) 0x80;
        b[1] = (byte) 0x01;
        b[2] = (byte) 0xe6;
        b[3] = (byte) 0;
        b[4] = 0;

        writeEEPROM(index, b);
        index += b.length;
        log.info("done writing " + records.size() + " records to EEPROM");
//        frame.dispose();

    }

    /**
     * downloads firmware to the FX2 RAM from a hex file.
     *
     * @param hexFileResourcePath a full path pointing to a resource containing
     * the firmware as output from compiler in Intel hex format. This resource
     * is a file that is somewhere in the classpath, i.e. it is a file that is
     * included in the project jar. For example:
     * "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAER_FX2LP_Retina.hex"
     * @see #FIRMWARE_FILENAME_TMPDIFF128_HEX
     * @see #FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX
     */
    synchronized public void downloadFirmwareHex(String hexFileResourcePath) throws HardwareInterfaceException {

        log.info("downloading to RAM firmware file " + hexFileResourcePath);

//        b = new byte[12];
//        b[0] = (byte) 0xC2; // write C2 load format header
//        b[1] = (byte) (VID & 0xFF);    // vid LSB
//        b[2] = (byte) ((VID & 0xFF00) >>> 8); // vid MSB
//        b[3] = (byte) (PID & 0xFF);
//        b[4] = (byte) ((PID & 0xFF00) >>> 8);
//        b[5] = (byte) (DID & 0xFF);
//        b[6] = (byte) ((DID & 0xFF00) >>> 8);
//        b[7] = (byte) (0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)
        HexFileParser parser;
        try {
            parser = new HexFileParser(hexFileResourcePath);
        } catch (FileNotFoundException e) {
            throw new HardwareInterfaceException(e.getMessage() + ": cannot open resource " + hexFileResourcePath);
        } catch (IOException e2) {
            throw new HardwareInterfaceException(e2.getMessage() + ": cannot open resource " + hexFileResourcePath);

        }
        ArrayList<HexFileParser.Record> records = parser.getRecords();

        log.info("Hex file has " + records.size() + " records");
        set8051Reset(true);

        // now for each hex file record, we must write this record, contiguous with the last one, and each record written to
        // flash must contain the starting address of how many bytes there are (up to 1023) and where the memory should go.
        // now write hex file records, one by one
        for (HexFileParser.Record r : records) {
            download8051RAM(r.address, r.data);
        }

        log.info("done writing hex file to RAM");

        set8051Reset(false);
    }

    /**
     * adds a listener for new events captured from the device. Actually gets
     * called whenever someone looks for new events and there are some using
     * acquireAvailableEventsFromDriver, not when data is actually captured by
     * AEReader. Thus it will be limited to the users sampling rate, e.g. the
     * game loop rendering rate.
     *
     * @param listener the listener. It is called with a PropertyChangeEvent
     * when new events are received by a call to
     * {@link #acquireAvailableEventsFromDriver}. These events may be accessed
     * by calling {@link #getEvents}.
     */
    @Override
    public void addAEListener(AEListener listener) {
        support.addPropertyChangeListener(listener);
    }

    @Override
    public void removeAEListener(AEListener listener) {
        support.removePropertyChangeListener(listener);
    }

    /**
     * starts reader buffer pool thread and enables in endpoints for AEs.
     * Subclasses *MUST* override this method to start their own customized
     * reader with their own translateEvents method.
     */
    public void startAEReader() throws HardwareInterfaceException {  // raphael: changed from private to protected, because i need to access this method
        throw new HardwareInterfaceException("This method should not be called - the CypressFX2 subclass should override startAEReader. Probably this is a blank device that requires programming.");
//        setAeReader(new AEReader(this));
//        allocateAEBuffers();
//        getAeReader().startThread(3); // arg is number of errors before giving up
//        HardwareInterfaceException.clearException();
    }
    long lastTimeEventCaptured = System.currentTimeMillis(); // used for timer to restart IN transfers, in case another connection, e.g. biasgen, has disabled them

    /**
     * Gets available events from driver. {@link HardwareInterfaceException} is
     * thrown if there is an error. {@link #overrunOccurred} will be reset after
     * this call.
     * <p>
     * This method also starts event acquisition if it is not running already.
     *
     * Not thread safe but does use the thread-safe swap() method of
     * AEPacketRawPool to swap data with the acquisition thread.
     *
     * @return number of events acquired. If this is zero there is no point in
     * getting the events, because there are none.
     * @throws HardwareInterfaceException
     * @see #setEventAcquisitionEnabled
     *
     * .
     */
    @Override
    public AEPacketRaw acquireAvailableEventsFromDriver() throws HardwareInterfaceException {
        if (!isOpened) {
            open();
        }

        // make sure event acquisition is running
        if (!inEndpointEnabled) {
            setEventAcquisitionEnabled(true);
        }

//        HardwareInterfaceException.clearException();
        // make sure that event translation from driver is allowed to run if need be, to avoid holding up event sender
//        Thread.currentThread().yield();
//        short[] addresses;
//        int[] timestamps;
        int nEvents;

        // getString the 'active' buffer for events (the one that has just been written by the hardware thread)
//        synchronized(aePacketRawPool){ // synchronize on aeReader so that we don't try to access the events at the same time
        aePacketRawPool.swap();
        lastEventsAcquired = aePacketRawPool.readBuffer();
//        log.info(this+" acquired "+lastEventsAcquired);
//            addresses=events.getAddresses();
//            timestamps=events.getTimestamps();
        nEvents = lastEventsAcquired.getNumEvents();
//        System.out.println(nEvents+" events");
        eventCounter = 0;
        realTimeEventCounterStart = 0;

        computeEstimatedEventRate(lastEventsAcquired);
        if (nEvents != 0) {
            support.firePropertyChange(PROPERTY_CHANGE_NEW_EVENTS, null, lastEventsAcquired); // call listeners
//        }
        }
        return lastEventsAcquired;

//        events=new AEPacketRaw(nEvents);
//        // reuse same packet to avoid constant new'ing
//        events.allocate(nEvents);
//        if(nEvents==0){
////            log.warning("got zero events from "+this);
//            computeEstimatedEventRate(null);
//            events.clear();
//            return events;
//        }else{
//            System.arraycopy(addresses, 0, events.getAddresses(), 0, nEvents);
//            System.arraycopy(timestamps, 0, events.getTimestamps(), 0, nEvents);
//            events.setNumEvents(nEvents);
//            computeEstimatedEventRate(events);
//            support.firePropertyChaNEW_EVENTS_PROPERTY_CHANGEY_CHANGE); // call listeners
//            return events;
//        }
    }

    /**
     * the max capacity of this USB2 bus interface is 24MB/sec/4 bytes/event
     */
    @Override
    public int getMaxCapacity() {
        return 6000000;
    }
    private int estimatedEventRate = 0;

    /**
     * @return event rate in events/sec as computed from last acquisition.
     *
     */
    @Override
    public int getEstimatedEventRate() {
        return estimatedEventRate;
    }

    /**
     * computes the estimated event rate for a packet of events
     */
    void computeEstimatedEventRate(AEPacketRaw events) {
        if ((events == null) || (events.getNumEvents() < 2)) {
            estimatedEventRate = 0;
        } else {
            int[] ts = events.getTimestamps();
            int n = events.getNumEvents();
            int dt = ts[n - 1] - ts[0];
            estimatedEventRate = (int) ((1e6f * n) / dt);
        }
    }

    /**
     * Returns the number of events acquired by the last call to {@link
     * #acquireAvailableEventsFromDriver }
     *
     * @return number of events acquired
     */
    @Override
    public int getNumEventsAcquired() {
        return aePacketRawPool.readBuffer().getNumEvents();
    }

    /**
     * Reset the timestamps to zero. This has two effects. First it sends a
     * vendor request down the control endpoint to tell the device to reset its
     * own internal timestamp counters. Second, it tells the AEReader object to
     * reset its timestamps, meaning to reset its unwrap counter.
     */
    @Override
    synchronized public void resetTimestamps() {
        log.info(this + ".resetTimestamps(): zeroing timestamps");
        int status = 0; // don't use global status in this function
        dontwrap = true;  // this is a flag that is reset in translateEvents method
        // send vendor request for device to reset timestamps
        if (gUsbIo == null) {
            throw new RuntimeException("device must be opened before sending this vendor request");
        }

        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = VENDOR_REQUEST_RESET_TIMESTAMPS;
        VendorRequest.Index = 0;

        VendorRequest.Value = 0;
        USBIO_DATA_BUFFER dataBuffer = new USBIO_DATA_BUFFER(1);
        dataBuffer.setNumberOfBytesToTransfer(1);
        //        dataBuffer.Buffer()[0]=1;
        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);
        if (status != USBIO_ERR_SUCCESS) {
            log.warning("CypressFX2.resetTimestamps: couldn't send vendor request to reset timestamps");
        }
        if (getAeReader() != null) {
            getAeReader().resetTimestamps(); // reset wrap counter and flush buffers
        } else {
            log.warning("CypressFX2.resetTimestamps(): reader not yet started, can't reset timestamps");
//        log.info(this+" notifying waiting threads that timestamps have been reset");
//        notifyAll(); // notify waiting threads (e.g. StereoPairHardwareInterface) that timestamps have been reset
        }
    }

    /**
     * Reset the entire pixel array. Some interfaces may not support this
     * functionality; they may not implement this vendor request. No exceptions
     * are thrown but a warning mesasge is printed.
     */
    public void resetPixelArray() {
        // send vendor request for device to reset array
        int status = 0; // don't use global status in this function
        if (gUsbIo == null) {
            throw new RuntimeException("device must be opened before sending this vendor request");
        }

        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = VENDOR_REQUEST_DO_ARRAY_RESET;
        VendorRequest.Index = 0;

        VendorRequest.Value = 0;
        USBIO_DATA_BUFFER dataBuffer = new USBIO_DATA_BUFFER(1);
        dataBuffer.setNumberOfBytesToTransfer(1);
        //        dataBuffer.Buffer()[0]=1;
        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);
        if (status != USBIO_ERR_SUCCESS) {
            log.warning("CypressFX2.resetPixelArray: couldn't send vendor request to reset array");
        }
    }
    protected boolean arrayResetEnabled = false;

    /**
     * set the board LED state. Useful for debugging. Not available for
     * CypressFX2MonitorSequencer
     *
     * @param value true to turn it on, false to turn it off.
     */
    synchronized public void setLed(boolean value) {
        // send vendor request for device to reset array
        int status = 0; // don't use global status in this function
        if (gUsbIo == null) {
            throw new RuntimeException("device must be opened before sending this vendor request");
        }

        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = VENDOR_REQUEST_SET_LED;
        VendorRequest.Index = 0;

        VendorRequest.Value = (short) (value ? 0 : 1);  // this is the request bit, if value true, send value 0, false send value 1
        // on the board, 1 actually turns off the LED because the anode is tied to Vdd and the  cathode to the GPIO output

        USBIO_DATA_BUFFER dataBuffer = new USBIO_DATA_BUFFER(0); // no data, value is in request value
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);

        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);
        if (status != USBIO_ERR_SUCCESS) {
            log.warning("CypressFX2.resetPixelArray: couldn't send vendor request to set LED");
        }
    }

    /**
     * Is true if an overrun occured in the driver
     * (><code> AE_BUFFER_SIZE</code> events) during the period before the last
     * time {@link
     * #acquireAvailableEventsFromDriver } was called. This flag is cleared by
     * {@link #acquireAvailableEventsFromDriver}, so you need to check it before
     * you acquire the events.
     * <p>
     * If there is an overrun, the events grabbed are the most ancient; events
     * after the overrun are discarded. The timestamps continue on but will
     * probably be lagged behind what they should be.
     *
     * @return true if there was an overrun.
     */
    @Override
    public boolean overrunOccurred() {
        //        synchronized(aePacketRawPool){
        return aePacketRawPool.readBuffer().overrunOccuredFlag;
        //        }
    }

    /**
     * Closes the device. Never throws an exception.
     */
    @Override
    synchronized public void close() {
        if (!isOpen()) {
            return;
        }

        try {
            setEventAcquisitionEnabled(false);

            if (asyncStatusThread != null) {
                asyncStatusThread.shutdownThread();
                asyncStatusThread.unbind();
                asyncStatusThread.close();
            }
        } catch (HardwareInterfaceException e) {
            e.printStackTrace();
        }

        gUsbIo.close();
        gUsbIo.releaseDevice();

        inEndpointEnabled = false;
        isOpened = false;
    }
    // not really necessary to stop this thread, i believe, because close will unbind already according to usbio docs

    public void stopAEReader() {
        final AEReader reader = getAeReader();

        if (reader != null) {
            reader.shutdownThread();
            reader.unbind();
            reader.close();

            setAeReader(null);
        } else {
            CypressFX2.log.warning("null reader, nothing to stop");
        }
    }

    /**
     * sends vendor request to trigger an immediate commit of whatever is in the
     * endpoint fifo immediately. next call to <@link
     * #acquireAvailableEventsFromDriver} will getString these events if you
     * wait a bit.
     */
    synchronized public void requestEarlyTransfer() throws HardwareInterfaceException {
        // start getting events by sending vendor request 0xb3 to control endpoint 0
        // documented in firmware FX2_to_extFIFO.c

        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();
        int status = 0; // don't use global status in this function

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = VENDOR_REQUEST_EARLY_TRANFER;
        VendorRequest.Index = 0;

        USBIO_DATA_BUFFER dataBuffer = new USBIO_DATA_BUFFER(1);
        VendorRequest.Value = 0; // (byte)VENDOR_REQUEST_START_TRANSFER;
        dataBuffer = new USBIO_DATA_BUFFER(1);
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        dataBuffer.Buffer()[0] = 1;
        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);
        if (status != USBIO_ERR_SUCCESS) {
            throw new HardwareInterfaceException("Unable to send vendor request to send events early: " + UsbIo.errorText(status));
        }
        HardwareInterfaceException.clearException();

    }

    /**
     * @return true if inEndpoint was enabled. However, some other connection
     * (e.g. biasgen) could have disabled the in transfers.
     */
    public boolean isInEndpointEnabled() {
        return this.inEndpointEnabled;
    }

    /**
     * sends a vendor request to enable or disable in transfers of AEs
     *
     * @param inEndpointEnabled true to send vendor request to enable, false to
     * send request to disable
     */
    public void setInEndpointEnabled(final boolean inEndpointEnabled) throws HardwareInterfaceException {
        log.info("Setting IN endpoint enabled=" + inEndpointEnabled);
        if (inEndpointEnabled) {
            enableINEndpoint();
        } else {
            disableINEndpoint();
        }
    }

    protected synchronized void enableINEndpoint() throws HardwareInterfaceException {
        // start getting events by sending vendor request 0xb3 to control endpoint 0
        // documented in firmware FX2_to_extFIFO.c
//        System.out.println("USBAEMonitor.enableINEndpoint()");
        // make vendor request structure and populate it
        if (gUsbIo == null) {
            log.warning("CypressFX2.enableINEndpoint(): null USBIO device");
            return;
        }
        int status = 0; // don't use global status in this function
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = VENDOR_REQUEST_START_TRANSFER;
        VendorRequest.Index = 0;

        VendorRequest.Value = 0;
        USBIO_DATA_BUFFER dataBuffer = new USBIO_DATA_BUFFER(0);
        dataBuffer.setNumberOfBytesToTransfer(0);
        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);
        if (status != USBIO_ERR_SUCCESS) {
            close();
            throw new HardwareInterfaceException("Unable to send vendor request to send events: " + UsbIo.errorText(status));
        } else {
            inEndpointEnabled = true;
        }
        HardwareInterfaceException.clearException();
    }

    /**
     * // stop endpoint sending events by sending vendor request 0xb4 to
     * control endpoint 0 // these requests are documented in firmware file
     * FX2_to_extFIFO.c
     */
    protected synchronized void disableINEndpoint() {

        // make vendor request structure and populate it
        int status = 0; // don't use global status in this function
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = VENDOR_REQUEST_STOP_TRANSFER;
        VendorRequest.Index = 0;

        VendorRequest.Value = 0;
        USBIO_DATA_BUFFER dataBuffer = new USBIO_DATA_BUFFER(0);
        dataBuffer.setNumberOfBytesToTransfer(0);
        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);
        if (status != USBIO_ERR_SUCCESS) {
            log.info("disableINEndpoint: couldn't send vendor request to disable IN transfers--it could be that device is gone or sendor is OFF and and completing GPIF cycle");
        } else {
            inEndpointEnabled = false;
        }
        HardwareInterfaceException.clearException();
    }

    @Override
    public PropertyChangeSupport getReaderSupport() {
        return support;
    }

    /**
     * This threads reads asynchronous status or other data from the device. It
     * handles timestamp reset messages from the device and possibly other types
     * of data. It fires PropertyChangeEvent
     * {@link #PROPERTY_CHANGE_ASYNC_STATUS_MSG} on receiving a message
     *
     * @author tobi delbruck
     * @see #getSupport()
     */
    protected class AsyncStatusThread extends UsbIoReader {

        UsbIoPipe pipe;
        CypressFX2 monitor;
        boolean stop = false;
        byte msg;
        public static final int STATUS_PRIORITY = Thread.MAX_PRIORITY; // Thread.NORM_PRIORITY+2

        public AsyncStatusThread(CypressFX2 monitor) {
            super();
            this.monitor = monitor;

            int status;
            status = bind(monitor.getInterfaceNumber(), STATUS_ENDPOINT_ADDRESS, gDevList, GUID);
            if (status != USBIO_ERR_SUCCESS) {
                log.warning("error binding to pipe for EP1 for device status: " + UsbIo.errorText(status) + ", not starting AsyncStatusThread");
                return;
            }
            USBIO_PIPE_PARAMETERS pipeParams = new USBIO_PIPE_PARAMETERS();
            pipeParams.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
            status = setPipeParameters(pipeParams);
            if (status != USBIO_ERR_SUCCESS) {
                log.warning("can't set pipe parameters: " + UsbIo.errorText(status) + ": AsyncStatusThread may not function properly");
            }
        }

        @Override
        public void startThread(int MaxIoErrorCount) {
            allocateBuffers(256, 3); // size of buffers and number of buffers on host side. Device side endpoint is 64 bytes. That means multiple device packets can be queued up on host side in these buffers.
            super.startThread(MaxIoErrorCount);
            T.setPriority(STATUS_PRIORITY); // very important that this thread have priority or the acquisition will stall on device side for substantial amounts of time!
            T.setName("AsyncStatusThread");
        }

        @Override
        public void processData(UsbIoBuf buffer) {
            if (buffer.BytesTransferred > 0) {
                msg = buffer.BufferMem[0];

                switch (msg) {
                    case STATUS_MSG_TIMESTAMPS_RESET:
                        AEReader rd = getAeReader();
                        if (rd != null) {
                            log.info("******** CypressFX2.AsyncStatusThread.run(): timestamps externally reset");
                            rd.resetTimestamps();
                        } else {
                            log.info("Received timestamp external reset message, but monitor is not running");
                        }
                        break;

                    case STATUS_MSG_OTHER:
                    default:
                        UsbIoBuf newbuf = new UsbIoBuf(buffer.BytesTransferred);

                        // Copy data to new buffer, this one is resubmitted right away.
                        System.arraycopy(buffer.BufferMem, 0, newbuf.BufferMem, 0, buffer.BytesTransferred);
                        newbuf.BytesTransferred = buffer.BytesTransferred;
                        newbuf.Status = buffer.Status;

                        support.firePropertyChange(PROPERTY_CHANGE_ASYNC_STATUS_MSG, null, newbuf); // tobi - send message to listeners
                    }
            } // we getString 0 byte read on stopping device
        }

        // called before buffer is submitted to driver
        @Override
        public void processBuffer(UsbIoBuf Buf) {
            Buf.NumberOfBytesToTransfer = Buf.Size;
            Buf.BytesTransferred = 0;
            Buf.OperationFinished = false;
        }

        @Override
        public void bufErrorHandler(UsbIoBuf Buf) {
            if (Buf.Status != USBIO_ERR_SUCCESS) {
                // print error
                // suppress CANCELED because it is caused by ABORT_PIPE
                if (Buf.Status != USBIO_ERR_CANCELED) {
                    log.warning("CypressFX2.AsyncStatusThread.bufErrorHandler(): USB buffer error: " + UsbIo.errorText(Buf.Status));
                }
                if (Buf.Status == USBIO_ERR_DEVICE_GONE) {
                    log.warning("CypressFX2.AsyncStatusThread.bufErrorHandler(): device gone, shutting down buffer pool thread");
                    monitor.close();
                }
            }
        }

        @Override
        public void onThreadExit() {
            freeBuffers();
        }

    }

    protected boolean relativeTimestampMode = false; // not used anymore //raphael: need this variable to branch in AEReader
    volatile boolean dontwrap = false; // used for resetTimestamps
    private int aeReaderFifoSize = prefs.getInt("CypressFX2.AEReader.fifoSize", 8192);

    /**
     * sets the buffer size for the aereader thread. optimal size depends on
     * event rate, for high event rates, at least 8k or 16k bytes should be
     * chosen, and low event rates need smaller buffer size to produce suitable
     * frame rates
     */
    public void setAEReaderFifoSize(int size) {
        this.aeReaderFifoSize = size;
        prefs.putInt("CypressFX2.AEReader.fifoSize", size);
    }
    private int aeReaderNumBuffers = prefs.getInt("CypressFX2.AEReader.numBuffers", 4);

    /**
     * sets the number of buffers for the aereader thread.
     */
    public void setAEReaderNumBuffers(int num) {
        this.aeReaderNumBuffers = num;
        prefs.putInt("CypressFX2.AEReader.numBuffers", num);
    }

    /**
     * AE reader class. the thread continually reads events into buffers. when a
     * buffer is read, ProcessData transfers and transforms the buffer data to
     * AE address and timestamps information and puts it in the addresses and
     * timestamps arrays. a call to acquireAvailableEventsFromDriver copies the
     * events to enw user arrays that can be accessed by getEvents() (this
     * packet is also returned by {@link #acquireAvailableEventsFromDriver}).
     * The relevant methods are synchronized so are thread safe.
     */
    public class AEReader extends UsbIoReader implements ReaderBufferControl {

        public final int MAX_NONMONOTONIC_TIME_EXCEPTIONS_TO_PRINT = 10;
        private int numNonMonotonicTimeExceptionsPrinted = 0;
        private int resetTimestampWarningCount = 0;
        int cycleCounter = 0;
        /**
         * This flag can be set asynchronously. In the AEReader, this flag may
         * be used to process this reset.
         */
        protected volatile boolean timestampsReset = false; // used to tell processData that another thread has reset timestamps
        final int BAD_WRAP_PRINT_INTERVAL = 100; // only print a warning every this many to avoid slowing down critical process
        /**
         * the priority for this monitor acquisition thread. This should be set
         * high (e.g. Thread.MAX_PRIORITY) so that the thread can start new
         * buffer reads in a timely manner so that the sender does not getString
         * blocked
         *
         */
        public static final int MONITOR_PRIORITY = Thread.MAX_PRIORITY; // Thread.NORM_PRIORITY+2
        /**
         * size of CypressFX2 USB fifo's in bytes.
         */
        public static final int CYPRESS_FIFO_SIZE = 512;
        /**
         * the default number of USB read buffers used in the reader
         */
        public static final int CYPRESS_NUM_BUFFERS = 2;
        /**
         * the number of capture buffers for the buffer pool for the translated
         * address-events. These buffers allow for smoother access to buffer
         * space by the event capture thread
         */
        private int numBuffers = prefs.getInt("CypressFX2.AEReader.numBuffers", CYPRESS_NUM_BUFFERS);
        /**
         * size of FIFOs in bytes used in AEReader for event capture from
         * device. This does not have to be the same size as the FIFOs in the
         * CypressFX2 (512 bytes). If it is too small, then there are frequent
         * thread context switches that can greatly slow down rendering loops.
         */
        private int fifoSize = prefs.getInt("CypressFX2.AEReader.fifoSize", CYPRESS_FIFO_SIZE); // 512;
        private final int RESET_TIMESTAMPS_INITIAL_PRINTING_LIMIT = 10;
        private final int RESET_TIMESTAMPS_WARNING_INTERVAL = 100000;
        CypressFX2 monitor = null;

        public AEReader(CypressFX2 m) throws HardwareInterfaceException {
            super();
            monitor = m;
            fifoSize = monitor.aeReaderFifoSize;
            numBuffers = monitor.aeReaderNumBuffers;

            int status;
            status = bind(monitor.getInterfaceNumber(), (byte) 0x86, gDevList, GUID); // device has already been opened so we don't need all the params
            if (status != USBIO_ERR_SUCCESS) {
                throw new HardwareInterfaceException("can't bind pipe: " + UsbIo.errorText(status));
            }

            USBIO_PIPE_PARAMETERS pipeParams = new USBIO_PIPE_PARAMETERS();
            pipeParams.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
            status = setPipeParameters(pipeParams);
            if (status != USBIO_ERR_SUCCESS) {
                throw new HardwareInterfaceException("can't set pipe parameters: " + UsbIo.errorText(status));
            }
        }

        @Override
        public String toString() {
            return "AEReader for " + CypressFX2.this;
        }

        /**
         * Subclasses must override this method to process the raw data to write
         * to the raw event packet buffers.
         *
         * @param buf the raw byte buffers
         */
        protected void translateEvents(UsbIoBuf buf) {
            log.warning("Error: This method should never be called, it must be overridden!!");
        }

        // called before buffer is submitted to driver
        @Override
        public void processBuffer(UsbIoBuf Buf) {
            Buf.NumberOfBytesToTransfer = Buf.Size;
            Buf.BytesTransferred = 0;
            Buf.OperationFinished = false;
            //            System.out.println("ProcessBuffer (before read)");
        }

        /**
         * Resets the timestamp unwrap value and sets flag timestampsReset.
         */
        synchronized public void resetTimestamps() {
            if ((resetTimestampWarningCount < RESET_TIMESTAMPS_INITIAL_PRINTING_LIMIT) || ((resetTimestampWarningCount % RESET_TIMESTAMPS_WARNING_INTERVAL) == 0)) {
                log.info(CypressFX2.this + ": wrapAdd=" + wrapAdd + ", zeroing it");
            }
            if (resetTimestampWarningCount == RESET_TIMESTAMPS_INITIAL_PRINTING_LIMIT) {
                log.warning("will only print reset timestamps message every " + RESET_TIMESTAMPS_WARNING_INTERVAL + " times now\nCould it be that you are trying to inject sync events using the DVS128 IN pin?\nIf so, select the  \"Enable sync events output\"  option in the DVS128 menu");
            }
            resetTimestampWarningCount++;

            wrapAdd = WRAP_START;
            timestampsReset = true; // will inform reader thread that timestamps are reset
        }

        // log packet times
//        final int NTIMES=100;
//        long[] times=new long[NTIMES];
//        PrintWriter timeWriter=null;
//        long lastTime=System.nanoTime();
        /**
         * Called on completion of read on a data buffer is received from USBIO
         * driver.
         *
         * @param Buf the data buffer with raw data
         */
        @Override
        public void processData(UsbIoBuf Buf) {
            cycleCounter++;

            usbPacketStatistics.addSample(Buf);

////             instrument cycle times
//            long thisTime=System.nanoTime();
//            times[cycleCounter%NTIMES]=thisTime-lastTime;
//            lastTime=thisTime;
//            if(cycleCounter%NTIMES==0){
//                try {
//                    if(timeWriter==null){
//                        timeWriter=new PrintWriter("cycleTimes.csv");
//                        log.info("saving CypressFX2.processData cycle times to cycleTimes.cvs in startup folder");
//                    }
//                    for(long t:times){
//                        timeWriter.format("%d\n",t);
//                    }
////                    timeWriter.flush();
//                } catch (FileNotFoundException ex) {
//                    ex.printStackTrace();
//                }
//            }
            if (!((Buf.Status == USBIO_ERR_SUCCESS) || (Buf.Status == USBIO_ERR_CANCELED))) {
                log.warning("cycleCounter=" + cycleCounter + " Bytes transferred=" + Buf.BytesTransferred + "  Status: " + UsbIo.errorText(Buf.Status));
                monitor.close(); // TODO we own hardware interface, but we also own the AEPackerRawPool, which may be owned by AEMonitor, which could be waiting for it. Therefore we can get deadlock here if we do this close inside the aePacketRawPool synchronized block below (tobi)

            } else {
                synchronized (aePacketRawPool) {// sync so that we don't try to copy events while buffer is being translated
                    if ((Buf.Status == USBIO_ERR_SUCCESS) || (Buf.Status == USBIO_ERR_CANCELED)) {
                        translateEvents(Buf);
//                    //                System.out.println("ProcessData: "+Buf.BytesTransferred+" bytes transferred: ");
//                    if ((monitor.getPID()==CypressFX2.PID_TMPDIFF128_RETINA) && (monitor.getDID()==CypressFX2.DID_STEREOBOARD))   {
//                        translateEventsWithCPLDEventCode(Buf);
//                    } else if ((monitor.getPID()==PID_USBAERmini2) && (monitor.getDID()==(short)0x0001) ) {
//                        translateEventsWithCPLDEventCode(Buf);
//                      //  CypressFX2MonitorSequencer seq=(CypressFX2MonitorSequencer)(CypressFX2.this);
//                        //                    seq.mapPacket(captureBufferPool.active());
//
//                    } else if ((monitor.getPID()==CypressFX2.PID_TMPDIFF128_FX2_SMALL_BOARD) ||( monitor.getPID()==CypressFX2.PID_DVS128_REV0 )) { // the new retina board with a CPLD
//                        translateEventsWithCPLDEventCode(Buf);
//                    } else if ((monitor.getPID()==PID_USBAERmini2) || (monitor.getPID()==PID_USB2AERmapper) ) { // USBAERmini2 with old firmware
//                        translateEventsFromOriginalUSB2AERmini2WithOriginalFirmware(Buf);
//                      //  CypressFX2MonitorSequencer seq=(CypressFX2MonitorSequencer)(CypressFX2.this);
//                        //                    seq.mapPacket(captureBufferPool.active());
//
//                    } else if(monitor.getPID()==PID_TCVS320_RETINA){
//                        translateEvents_TCVS320(Buf);
//                    } else { // original format with timestamps that just wrap
//                        translateEventsFromTmpdiff128OriginalBoard(Buf);
//                    }
//                    //                pop.play();

                        if ((chip != null) && (chip.getFilterChain() != null) && (chip.getFilterChain().getProcessingMode() == FilterChain.ProcessingMode.ACQUISITION)) {
                            // here we do the realTimeFiltering. We finished capturing this buffer's worth of events, now process them
                            // apply realtime filters and realtime (packet level) mapping

                            // synchronize here so that rendering thread doesn't swap the buffer out from under us while we process these events
                            // aePacketRawPool.writeBuffer is also synchronized so we getString the same lock twice which is ok
                            AEPacketRaw buffer = aePacketRawPool.writeBuffer();
                            int[] addresses = buffer.getAddresses();
                            int[] timestamps = buffer.getTimestamps();
                            realTimeFilter(addresses, timestamps);
                        }
                    }
                    if (timestampsReset) {
//                    log.info("timestampsReset: flushing aePacketRawPool buffers");
//                    don't flush, just let the old data through since it is still data
//                    aePacketRawPool.reset();  //this is already done in resetTimestamps() why do it again here?
                        timestampsReset = false;
                    }
                }
            }
        }

        final int WRAP_START = 0; //(int)(0xFFFFFFFFL&(2147483648L-0x400000L)); // set high to test big wrap 1<<30;
        /**
         * wrapAdd is the time to appendCopy to short timestamp to unwrap it
         */
        protected int wrapAdd = WRAP_START; //0;
        protected int lastwrap = WRAP_START; //0;
        protected int currentwrap = WRAP_START; //0;
        protected int lastWrapAdd = 0;
        /**
         * used to indicate a 32 bit timestamp wrap
         */
        protected boolean wrappedBig = false;  // indicates that wrapAdd has just wrapped itself, so that we should allow nonmonotonic timestamp

        @Override
        public void bufErrorHandler(UsbIoBuf Buf) {
            if (Buf.Status != USBIO_ERR_SUCCESS) {
                // print error
                // suppress CANCELED because it is caused by ABORT_PIPE
                if (Buf.Status != USBIO_ERR_CANCELED) {
                    log.warning("USB buffer error: " + UsbIo.errorText(Buf.Status));
                }
                if (Buf.Status == USBIO_ERR_DEVICE_GONE) {
                    log.warning("CypressFX2.bufErrorHandler(): device gone, shutting down buffer pool thread");
                    monitor.close();
                }
            }
        }
        // virtual function, called in the context of worker thread

        /**
         *
         */
        @Override
        public void onThreadExit() {
            freeBuffers();
        }

        /**
         * overridden to change priority and name thread
         */
        @Override
        public void startThread(int MaxIoErrorCount) {
//            log.info("CypressFX2.AEReader.startThread()");
            allocateBuffers(getFifoSize(), getNumBuffers());
            super.startThread(MaxIoErrorCount);
            T.setPriority(MONITOR_PRIORITY); // very important that this thread have priority or the acquisition will stall on device side for substantial amounts of time!
            T.setName("AEReader");
//            System.out.println(this+ " event capture worker-thread started");
            monitor.aeReaderRunning = true;
            getSupport().firePropertyChange("readerStarted", false, true); // used in AEViewer to set up menus for changing buffer size
        }

        @Override
        public int getFifoSize() {
            return fifoSize;
        }

        @Override
        public void setFifoSize(int fifoSize) {
            if (fifoSize < CYPRESS_FIFO_SIZE) {
                log.warning("CypressFX2 fifo size clipped to device FIFO size " + CYPRESS_FIFO_SIZE);
                fifoSize = CYPRESS_FIFO_SIZE;
            }
            this.fifoSize = fifoSize;
            freeBuffers();
            allocateBuffers(fifoSize, numBuffers);
            prefs.putInt("CypressFX2.AEReader.fifoSize", fifoSize);
        }

        @Override
        public int getNumBuffers() {
            return numBuffers;
        }

        @Override
        public void setNumBuffers(int numBuffers) {
            this.numBuffers = numBuffers;
            freeBuffers();
            allocateBuffers(fifoSize, numBuffers);
            prefs.putInt("CypressFX2.AEReader.numBuffers", numBuffers);
        }

        /**
         * Applies the filterChain processing on the most recently captured
         * data. The processing is done by extracting the events just captured
         * and then applying the filter chain.
         * <strong>The filter outputs are discarded and will not be visble in
         * the rendering of the chip output, but may be used for motor control
         * or other purposes.
         * </strong>
         * <p>
         * TODO: at present this processing is redundant in that the most
         * recently captured events are copied to a different AEPacketRaw,
         * extracted to an EventPacket, and then processed. This effort is
         * duplicated later in rendering. This should be fixed somehow.
         *
         * @param addresses the raw input addresses; these are filtered in place
         * @param timestamps the input timestamps
         */
        private void realTimeFilter(int[] addresses, int[] timestamps) {

            if (!chip.getFilterChain().isAnyFilterEnabled()) {
                return;
            }
            int nevents = getNumRealTimeEvents();

            // initialize packets
            if (realTimeRawPacket == null) {
                realTimeRawPacket = new AEPacketRaw(nevents);  // TODO: expensive
            } else {
                realTimeRawPacket.ensureCapacity(nevents);//                // copy data to real time raw packet
//                if(addresses==null || timestamps==null){
//                    log.warning("realTimeFilter: addresses or timestamp array became null");
//                }else{
            }
            try {
                System.arraycopy(addresses, realTimeEventCounterStart, realTimeRawPacket.getAddresses(), 0, nevents);
                System.arraycopy(timestamps, realTimeEventCounterStart, realTimeRawPacket.getTimestamps(), 0, nevents);
            } catch (IndexOutOfBoundsException e) {
                e.printStackTrace();
            }
            realTimeEventCounterStart = eventCounter;
            //   System.out.println("RealTimeEventCounterStart: " + realTimeEventCounterStart + " nevents " + nevents + " eventCounter " + eventCounter);
            realTimeRawPacket.setNumEvents(nevents);
            // init extracted packet
            // if(realTimePacket==null)
            //   realTimePacket=new EventPacket(chip.getEventClass());
            // extract events for this filter. This duplicates later effort during rendering and should be fixed for later.
            // at present this may mess up everything else because the output packet is reused.

            // hack for stereo hardware interfaces - for real time processing we must label the eye bit here based on which eye our hardware
            // interface is. note the events are labeled here and the real time processing method is called for each low level hardware interface.
            // But each call will only getString events from one eye. it is important that the filterPacket method be sychronized (thread safe) because the
            // filter object may getString called by both AEReader threads at the "same time"
            if (chip.getHardwareInterface() instanceof StereoPairHardwareInterface) {
                StereoPairHardwareInterface stereoInterface = (StereoPairHardwareInterface) chip.getHardwareInterface();
                if (stereoInterface.getAemonLeft() == CypressFX2.this) {
                    stereoInterface.labelLeftEye(realTimeRawPacket);
                } else {
                    stereoInterface.labelRightEye(realTimeRawPacket);
                }
            }
            // regardless, we now extract to typed events for example and process
            realTimePacket = chip.getEventExtractor().extractPacket(realTimeRawPacket); //,realTimePacket);
            realTimePacket.setRawPacket(realTimeRawPacket);

            try {
                getChip().getFilterChain().filterPacket(realTimePacket);
            } catch (Exception e) {
                log.warning(e.toString() + ": disabling all filters");
                e.printStackTrace();
                for (EventFilter f : getChip().getFilterChain()) {
                    f.setFilterEnabled(false);
                }
            }
            // we don't do following because the results are an AEPacketRaw that still needs to be written to addresses/timestamps
            // and this is not done yet. at present results of realtime filtering are just not rendered at all.
            // that means that user will see raw events, e.g. if BackgroundActivityFilter is used, then user will still see all
            // events because the filters are not applied for normal rendering. (If they were applied, then the filters would
            // be in a funny state becaues they would process the same data more than once and out of order, resulting in all kinds
            // of problems.)
            // However, the graphical annotations (like the boxes drawn around clusters in RectangularClusterTracker)
            // done by the real time processing are still shown when the rendering thread calls the
            // annotate methods.

//            chip.getEventExtractor().reconstructRawPacket(realTimePacket);
        }

        @Override
        public PropertyChangeSupport getReaderSupport() {
            return support;
        }
    }

    private int getNumRealTimeEvents() {
        return eventCounter - realTimeEventCounterStart;
    }

    /**
     * Allocates internal memory for transferring data from reader to consumer,
     * e.g. rendering.
     */
    protected void allocateAEBuffers() {
        synchronized (aePacketRawPool) {
            aePacketRawPool.allocateMemory();
        }
    }

    /**
     * @return the size of the double buffer raw packet for AEs
     */
    @Override
    public int getAEBufferSize() {
        return aeBufferSize; // aePacketRawPool.writeBuffer().getCapacity();
    }

    /**
     * set the size of the raw event packet buffer. Default is AE_BUFFER_SIZE.
     * You can set this larger if you have overruns because your host processing
     * (e.g. rendering) is taking too long.
     * <p>
     * This call discards collected events.
     *
     * @param size of buffer in events
     */
    @Override
    public void setAEBufferSize(int size) {
        if ((size < 1000) || (size > 1000000)) {
            log.warning("ignoring unreasonable aeBufferSize of " + size + ", choose a more reasonable size between 1000 and 1000000");
            return;
        }
        this.aeBufferSize = size;
        prefs.putInt("CypressFX2.aeBufferSize", aeBufferSize);
        allocateAEBuffers();
    }

    @Override
    public void onAdd() {
        log.info("USBAEMonitor.onAdd(): device added");
    }

    @Override
    public void onRemove() {
        log.info("USBAEMonitor.onRemove(): device removed");
    }

    /**
     * start or stops the event acquisition. sends appropriate vendor request to
     * device and starts or stops the AEReader. Thread-safe on hardware
     * interface.
     *
     * @param enable boolean to enable or disable event acquisition
     */
    @Override
    public void setEventAcquisitionEnabled(boolean enable) throws HardwareInterfaceException {
        /* tobi commented synchronized but "deadlock" occurs only in debug mode, to try to solve problem of locking in exit menu because AEViewer waits on Thread.join but hardware interface is owned by AWT-EventQueue synchronized */
//        log.info("setting event acquisition="+enable);
        setInEndpointEnabled(enable);
        if (enable) {
            startAEReader();
        } else {
            stopAEReader();
        }
    }

    @Override
    public boolean isEventAcquisitionEnabled() {
        return isInEndpointEnabled();
    }

    @Override
    public String getTypeName() {
        return "CypressFX2";
    }
    /**
     * the first USB string descriptor (Vendor name) (if available)
     */
    protected USB_STRING_DESCRIPTOR stringDescriptor1 = new USB_STRING_DESCRIPTOR();
    /**
     * the second USB string descriptor (Product name) (if available)
     */
    protected USB_STRING_DESCRIPTOR stringDescriptor2 = new USB_STRING_DESCRIPTOR();
    /**
     * the third USB string descriptor (Serial number) (if available)
     */
    protected USB_STRING_DESCRIPTOR stringDescriptor3 = new USB_STRING_DESCRIPTOR();
    /**
     * The number of string desriptors - all devices have at least two (Vendor
     * and Product strings) but some may have in addition a third serial number
     * string. Default value is 2. Initialized to zero until device descriptors
     * have been obtained.
     */
    protected int numberOfStringDescriptors = 0;

    /**
     * returns number of string descriptors
     *
     * @return number of string descriptors: 2 for TmpDiff128, 3 for
     * MonitorSequencer
     */
    public int getNumberOfStringDescriptors() {
        return numberOfStringDescriptors;
    }
    /**
     * the USBIO device descriptor
     */
    protected USB_DEVICE_DESCRIPTOR deviceDescriptor = new USB_DEVICE_DESCRIPTOR();
    /**
     * the UsbIo interface to the device. This is assigned on construction by
     * the factory which uses it to open the device. here is used for all USBIO
     * access to the device
     */
    protected UsbIo gUsbIo = null;
    /**
     * the devlist handle for USBIO
     */
    protected long gDevList; // 'handle' (an integer) to an internal device list static to UsbIo

    /**
     * checks if device has a string identifier that is a non-empty string
     *
     * @return false if not, true if there is one
     */
    protected boolean hasStringIdentifier() {
        // getString string descriptor
        int status = gUsbIo.getStringDescriptor(stringDescriptor1, (byte) 1, 0);
        if (status != USBIO_ERR_SUCCESS) {
            return false;
        } else {
            if (stringDescriptor1.Str.length() > 0) {
                return true;
            }
        }
        return false;
    }

    /**
     * Constructs a new USB connection and opens it. Does NOT start event
     * acquisition.
     *
     * @see #setEventAcquisitionEnabled
     * @throws HardwareInterfaceException if there is an error opening device
     * @see #openUsbIo_minimal()
     */
    @Override
    public void open() throws HardwareInterfaceException {
//        log.info(Thread.currentThread()+": CypressFX2.open()");
        openUsbIo();
//        setEventAcquisitionEnabled(true); // don't enable anymore, do this instead in acquireAvailableEventsFromDriver if necessary
        HardwareInterfaceException.clearException();
    }

    /**
     * This method does the hard work of opening the device, downloading the
     * firmware, making sure everything is OK.
     * <p>
     * This method is synchronized to prevent multiple threads from trying to
     * open at the same time, e.g. a GUI thread and the main thread.
     * <p>
     * Opening the device after it has already been opened has no effect.
     *
     * @see #close
     * @throws HardwareInterfaceException if there is a problem. Diagnostics are
     * printed to stderr.
     */
    synchronized protected void openUsbIo() throws HardwareInterfaceException {

        //device has already been UsbIo Opened by now, in factory
        // opens the USBIOInterface device, configures it, binds a reader thread with buffer pool to read from the device and starts the thread reading events.
        // we got a UsbIo object when enumerating all devices and we also made a device list. the device has already been
        // opened from the UsbIo viewpoint, but it still needs firmware download, setting up pipes, etc.
        if (isOpened) {
//            log.warning("CypressFX2.openUsbIo(): already opened interface and setup device");
            return;
        }

        int status;

        gUsbIo = new UsbIo();
        gDevList = UsbIo.createDeviceList(GUID);
        status = gUsbIo.open(getInterfaceNumber(), gDevList, GUID);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            isOpened = false;
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): can't open USB device: " + UsbIo.errorText(status));
        }

        acquireDevice();

        // getString device descriptor (possibly before firmware download, when still bare cypress device or running off EEPROM firmware)
        status = gUsbIo.getDeviceDescriptor(deviceDescriptor);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getDeviceDescriptor: " + UsbIo.errorText(status));
        } else {
//            log.info("getDeviceDescriptor: Vendor ID (VID) "
//                    + HexString.toString((short)deviceDescriptor.idVendor)
//                    + " Product ID (PID) " + HexString.toString((short)deviceDescriptor.idProduct));
        }

        if (isBlankDevice()) {
            log.warning("blank device, downloading preferred firmware");
            // possibly download binary firmware to Cypress RAM
            downloadFirmwareBinaryToBlankDevice();

            boolean success = false;
            int triesLeft = 10;
            final long delay = 1000;
            while (!success && (triesLeft > 0)) {
                try {
                    Thread.sleep(delay);
                } catch (InterruptedException e) {
                }
                gDevList = UsbIo.createDeviceList(GUID);
                gUsbIo = new UsbIo();
                status = gUsbIo.open(getInterfaceNumber(), gDevList, GUID);
                if (status != USBIO_ERR_SUCCESS) {
                    UsbIo.destroyDeviceList(gDevList);
                    triesLeft--;
                } else {
                    success = true;
                }
            }
            if (!success) {
                throw new HardwareInterfaceException("openUsbIo: couldn't reopen device after firmware download and renumeration: " + UsbIo.errorText(status));
            } else {
                throw new HardwareInterfaceException("device firmware downloaded, a new instance must be constructed by the factory using the new VID/PID");
            }
        }

        try {
            unconfigureDevice(); // in case it was left configured from a terminated process
        } catch (HardwareInterfaceException e) {
            log.warning("CypressFX2.open(): can't unconfigure,will try simulated disconnect");
            int cycleStatus = gUsbIo.cyclePort();
            if (cycleStatus != USBIO_ERR_SUCCESS) {
                throw new HardwareInterfaceException("Error cycling port: " + UsbIo.errorText(cycleStatus));
            }
            throw new HardwareInterfaceException("couldn't unconfigure device");
        }

        // set configuration -- must do this BEFORE downloading firmware!
        if (deviceDescriptor.bNumConfigurations != 1) {
            throw new HardwareInterfaceException("number of configurations=" + deviceDescriptor.bNumConfigurations + " which is not 1 like it should be");
        }

        USBIO_SET_CONFIGURATION Conf = new USBIO_SET_CONFIGURATION();
        Conf.ConfigurationIndex = CONFIG_INDEX;
        Conf.NbOfInterfaces = CONFIG_NB_OF_INTERFACES;
        Conf.InterfaceList[0].InterfaceIndex = CONFIG_INTERFACE;
        Conf.InterfaceList[0].AlternateSettingIndex = CONFIG_ALT_SETTING;
        Conf.InterfaceList[0].MaximumTransferSize = CONFIG_TRAN_SIZE;
        status = gUsbIo.setConfiguration(Conf);
        if (status != USBIO_ERR_SUCCESS) {
//            gUsbIo.destroyDeviceList(gDevList);
            //   if (status !=0xE0001005)
            throw new HardwareInterfaceException("setting configuration: " + UsbIo.errorText(status));
        }

        //        try{Thread.currentThread().sleep(100);} catch(InterruptedException e){}; // pause for renumeration
        populateDescriptors(gUsbIo);

//        //        System.out.println("after firmware download and reenumeration, descriptors are");
//        // getString device descriptor
//        status = gUsbIo.getDeviceDescriptor(deviceDescriptor);
//        if (status != USBIO_ERR_SUCCESS) {
//            UsbIo.destroyDeviceList(gDevList);
//            throw new HardwareInterfaceException("getDeviceDescriptor: " + UsbIo.errorText(status));
//        } else {
////            log.info("getDeviceDescriptor: Vendor ID (VID) "
////                    + HexString.toString((short)deviceDescriptor.idVendor)
////                    + " Product ID (PID) " + HexString.toString((short)deviceDescriptor.idProduct));
//        }
//        if (deviceDescriptor.iManufacturer != 0) { // not blank device, getString string descriptors
//            if (deviceDescriptor.iSerialNumber != 0) {
//                this.numberOfStringDescriptors = 3;        // getString string descriptor
//            }
//            status = gUsbIo.getStringDescriptor(stringDescriptor1, (byte) 1, 0);
//            if (status != USBIO_ERR_SUCCESS) {
//                UsbIo.destroyDeviceList(gDevList);
//                throw new HardwareInterfaceException("getStringDescriptor 1: " + UsbIo.errorText(status));
//            } else {
////            log.info("getStringDescriptor 1: " + stringDescriptor1.Str);
//            }
//        this.numberOfStringDescriptors=1;  // it has at least 2
//
//            // getString string descriptor
//            // blank device has none
//            status = gUsbIo.getStringDescriptor(stringDescriptor2, (byte) 2, 0);
//            if (status != USBIO_ERR_SUCCESS) {
//                UsbIo.destroyDeviceList(gDevList);
//                throw new HardwareInterfaceException("getStringDescriptor 2: " + UsbIo.errorText(status));
//            } else {
////            log.info("getStringDescriptor 2: " + stringDescriptor2.Str);
//            }
//
//        this.numberOfStringDescriptors=2;  // it has at least 2
//            if (this.numberOfStringDescriptors == 3) {
//                // getString serial number string descriptor
//                status = gUsbIo.getStringDescriptor(stringDescriptor3, (byte) 3, 0);
//                if (status != USBIO_ERR_SUCCESS) {
//                    UsbIo.destroyDeviceList(gDevList);
//                    throw new HardwareInterfaceException("getStringDescriptor 3: " + UsbIo.errorText(status));
//                } else {
////                log.info("getStringDescriptor 3: " + stringDescriptor3.Str);
//                }
//            }
//        }
        if (!gUsbIo.isOperatingAtHighSpeed()) {
            log.warning("Device is not operating at USB 2.0 High Speed, performance will be limited to about 300 keps");
        }

        // getString pipe information and extract the FIFO size
        USBIO_CONFIGURATION_INFO ConfigurationInfo = new USBIO_CONFIGURATION_INFO();
        status = gUsbIo.getConfigurationInfo(ConfigurationInfo);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("getConfigurationInfo: " + UsbIo.errorText(status));
        }

        if (ConfigurationInfo.NbOfPipes == 0) {
//            gUsbIo.cyclePort();
            log.warning("no pipes to bind too - probably blank device");
//            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): didn't find any pipes to bind to");
        } else {

            // start the thread that listens for device status information (e.g. timestamp reset, other device data)
            asyncStatusThread = new AsyncStatusThread(this);
            asyncStatusThread.startThread(3); // starts reader to listen for async status messages
        }
//        log.info("resetting 8051");
//        set8051Reset(true);
//        set8051Reset(false);

        isOpened = true;

    }

    /**
     * Opens the device just enough to read the device descriptor but does not
     * start the reader or writer thread. If the device does not have a string
     * descriptor it is assumed that firmware must be downloaded to device RAM
     * and this is done automatically. The device is <strong>not configured by
     * this method. Vendor requests and probably other functionality will not be
     * available.</strong>. The device is left open this method returns.
     *
     * @throws net.sf.jaer.hardwareinterface.HardwareInterfaceException
     * @see #open()
     */
    synchronized protected void openUsbIo_minimal() throws HardwareInterfaceException {

        //device has already been UsbIo Opened by now, in factory
        // opens the USBIOInterface device, configures it, binds a reader thread with buffer pool to read from the device and starts the thread reading events.
        // we got a UsbIo object when enumerating all devices and we also made a device list. the device has already been
        // opened from the UsbIo viewpoint, but it still needs firmware download, setting up pipes, etc.
        if (isOpened) {
//            log.warning("CypressFX2.openUsbIo(): already opened interface and setup device");
            return;
        }

        int status;

        gUsbIo = new UsbIo();
        gDevList = UsbIo.createDeviceList(GUID);
        status = gUsbIo.open(getInterfaceNumber(), gDevList, GUID);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            isOpened = false;
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): can't open USB device: " + UsbIo.errorText(status));
        }

        // getString device descriptor (possibly before firmware download, when still bare cypress device or running off EEPROM firmware)
        status = gUsbIo.getDeviceDescriptor(deviceDescriptor);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getDeviceDescriptor: " + UsbIo.errorText(status));
        } else {
//            log.info("getDeviceDescriptor: Vendor ID (VID) "
//                    + HexString.toString((short)deviceDescriptor.idVendor)
//                    + " Product ID (PID) " + HexString.toString((short)deviceDescriptor.idProduct));
        }

        if (isBlankDevice()) {
            throw new BlankDeviceException("Blank Cypress FX2");
        }

        // possibly download binary firmware to Cypress RAM
        if (!this.hasStringIdentifier()) {
            downloadFirmwareBinaryToBlankDevice();

            boolean success = false;
            int triesLeft = 10;
            long delay = 400;
            while (!success && (triesLeft > 0)) {
                try {
                    Thread.sleep(delay);
                } catch (InterruptedException e) {
                }
                gDevList = UsbIo.createDeviceList(GUID);
                gUsbIo = new UsbIo();
                status = gUsbIo.open(getInterfaceNumber(), gDevList, GUID);
                if (status != USBIO_ERR_SUCCESS) {
                    UsbIo.destroyDeviceList(gDevList);
                    triesLeft--;
                } else {
                    success = true;
                }
            }
            if (!success) {
                throw new HardwareInterfaceException("openUsbIo_minimal: couldn't reopen device after firmware RAM download to blank device and renumeration: " + UsbIo.errorText(status));
            }
        }
//        try{
//            unconfigureDevice(); // in case it was left configured from a terminated process
//        }catch(HardwareInterfaceException e){
//            log.warning("CypressFX2.open(): can't unconfigure,will try simulated disconnect");
//            int cycleStatus=gUsbIo.cyclePort();
//            if(cycleStatus!=USBIO_ERR_SUCCESS){
//                throw new HardwareInterfaceException("Error cycling port: "+UsbIo.errorText(cycleStatus));
//            }
//            throw new HardwareInterfaceException("couldn't unconfigure device");
//        }

//        // set configuration -- must do this BEFORE downloading firmware!
//        USBIO_SET_CONFIGURATION Conf = new USBIO_SET_CONFIGURATION();
//        Conf.ConfigurationIndex = CONFIG_INDEX;
//        Conf.NbOfInterfaces = CONFIG_NB_OF_INTERFACES;
//        Conf.InterfaceList[0].InterfaceIndex = CONFIG_INTERFACE;
//        Conf.InterfaceList[0].AlternateSettingIndex = CONFIG_ALT_SETTING;
//        Conf.InterfaceList[0].MaximumTransferSize = CONFIG_TRAN_SIZE;
//        status = gUsbIo.setConfiguration(Conf);
//        if (status != USBIO_ERR_SUCCESS) {
////            gUsbIo.destroyDeviceList(gDevList);
//            //   if (status !=0xE0001005)
//            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): setting configuration after firmware download: "+UsbIo.errorText(status));
//        }
        //        try{Thread.currentThread().sleep(100);} catch(InterruptedException e){}; // pause for renumeration
        populateDescriptors(gUsbIo);
    }

    /**
     * unconfigure device in case it was still configured from a prior
     * terminated process
     *
     * @throws net.sf.jaer.hardwareinterface.HardwareInterfaceException
     */
    protected synchronized void unconfigureDevice() throws HardwareInterfaceException {
        int status;
//        System.out.println("CypressFX2RetinaBiasgen.unconfigureDevice()");
        status = gUsbIo.unconfigureDevice();
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            //System.out.println("unconfigureDevice: "+UsbIo.errorText(status));
            //            throw new USBAEMonitorException("getStringDescriptor: "+gUsbIo.errorText(status));
            throw new HardwareInterfaceException("unconfigureDevice: " + UsbIo.errorText(status));
            //            System.out.println("getConfigurationInfo ok");
        }
        //        System.out.println("unconfigured device");
    }

    /**
     * return the string USB descriptors for the device
     *
     * @return String[] of length 2 or 3 of USB descriptor strings.
     */
    @Override
    public String[] getStringDescriptors() {
        if (stringDescriptor1 == null) {
            log.warning("USBAEMonitor: getStringDescriptors called but device has not been opened");
            String[] s = new String[numberOfStringDescriptors];
            for (int i = 0; i < numberOfStringDescriptors; i++) {
                s[i] = "";
            }
            return s;
        }
        String[] s = new String[numberOfStringDescriptors];
        s[0] = stringDescriptor1.Str == null ? "" : stringDescriptor1.Str;
        s[1] = stringDescriptor2.Str == null ? "" : stringDescriptor2.Str;
        if (numberOfStringDescriptors == 3) {
            s[2] = stringDescriptor3.Str == null ? "" : stringDescriptor3.Str;
        }
        return s;
    }

    /**
     * return the USB VID/PID of the interface
     *
     * @return int[] of length 2 containing the Vendor ID (VID) and Product ID
     * (PID) of the device. First element is VID, second element is PID.
     */
    public int[] getVIDPID() {
        if (deviceDescriptor == null) {
            log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
            return new int[2];
        }
        int[] n = new int[2];
        n[0] = deviceDescriptor.idVendor;
        n[1] = deviceDescriptor.idProduct;
        return n;
    }

    @Override
    public short getVID_THESYCON_FX2_CPLD() {
        if (deviceDescriptor == null) {
            log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
            return 0;
        }
        // int[] n=new int[2]; n is never used
        return (short) deviceDescriptor.idVendor;
    }

    @Override
    public short getPID() {
        if (deviceDescriptor == null) {
            log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
            return 0;
        }
        return (short) deviceDescriptor.idProduct;
    }

    /**
     * @return bcdDevice (the binary coded decimel device version
     */
    @Override
    public short getDID() { // this is not part of USB spec in device descriptor.
        return (short) deviceDescriptor.bcdDevice;
    }

    /**
     * reports if interface is {@link #open}.
     *
     * @return true if already open
     */
    @Override
    public boolean isOpen() {
        return isOpened;
    }

    /**
     * Loads a binary firmware file into memory. The filename is used to search
     * the resource path (i.e. the jar archives on the classpath). If the file
     * is not found in the resources (jars or classes on classpath) then the
     * file system is checked.
     *
     * @param firmwareFilename the resource path
     *
     */
    public byte[] loadBinaryFirmwareFile(String firmwareFilename) throws IOException {
        log.info("loading to memory firmware file " + firmwareFilename);
        InputStream firmwareFileStream;
        byte[] fwBuffer;
        // load firmware file (this is binary file of 8051 firmware)
        try {
            firmwareFileStream = getClass().getResourceAsStream(firmwareFilename);
            if (firmwareFileStream != null) {
                int len = firmwareFileStream.available();  // we must loop available() according to http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6278051
                //              log.info("firmare length: " + len);
                fwBuffer = new byte[firmwareFileStream.available()];
                int numBytesRead = firmwareFileStream.read(fwBuffer);
                //              log.info("bytes read: "+ numBytesRead);

                int ki = 1;
                int maxtries = 5;
                while (numBytesRead < len) {
                    log.info("Could only read " + numBytesRead + " of " + len + ", trying " + ki + "/" + maxtries + " more times.");

                    int rd = firmwareFileStream.read(fwBuffer, numBytesRead, len - numBytesRead);
                    numBytesRead += rd;
                    ki++;
                    if (ki > 5) {
                        throw new IOException("could not read binary firmware file");
                    }
                }
                firmwareFileStream.close();
            } else {
                log.info("could not get resource as stream");
                fwBuffer = loadBinaryFirmwareFileSystemFile(firmwareFilename);
            }
        } catch (IOException e) {
            close();
            log.warning(e.getMessage());
            throw new IOException("can't load binary Cypress FX2 firmware file " + firmwareFilename);
        }
        return fwBuffer;
    }

    /**
     * Loads a binary firmware file into memory from a file system path (as
     * opposed to resource path).
     *
     * @param firmwareFilename the file path
     *
     */
    public byte[] loadBinaryFirmwareFileSystemFile(String firmwareFilename) throws IOException {
        log.info("reading firmware file " + firmwareFilename);
        InputStream firmwareFileStream;
        byte[] fwBuffer;
        // load firmware file (this is binary file of 8051 firmware)
        try {
            File f = new File(firmwareFilename);
            firmwareFileStream = new FileInputStream(f);
            fwBuffer = new byte[firmwareFileStream.available()];
            firmwareFileStream.read(fwBuffer);
            firmwareFileStream.close();
        } catch (IOException e) {
            close();
            log.warning(e.getMessage());
            throw new IOException("can't load binary Cypress FX2 firmware file " + firmwareFilename + "\nYou may need to choose a new default firmware file if you moved your jAER installation since setting this file.");
        }
        return fwBuffer;
    }

    /**
     * downloads firmware to FX2 RAM. adapted from John Arthur's example, which
     * comes from Cypress example. Firmware file is a binary file produced by
     * uVision2 (Keil) from source code for firmware.
     * <p>
     * Firmware that is actually downloaded depends on discovered PID of device.
     * If the PID is discovered to be a bare CypressFX2, then a dialog is shown
     * that user can use to program the VID/PID of the device.
     * <p>
     * In addition, there is a problem if firmware is downloaded more than once
     * to an FX2LP device between hard resets. Therefore if this method detects
     * that the device has string identitifers, it assumes the firmware has
     * already been downloaded.
     *
     *
     * Firmware file is loaded as a resource from the jar archive.
     */
    synchronized public void downloadFirmwareBinary(String firmwareFilename) throws HardwareInterfaceException {

        byte[] fwBuffer; // buffer to hold contents of firmware file (binary 8051 code)

        try {
            fwBuffer = loadBinaryFirmwareFile(firmwareFilename);
        } catch (IOException e) {
            close();
            log.warning(e.getMessage());
            throw new HardwareInterfaceException("can't load binary Cypress FX2 firmware file " + firmwareFilename);
        }

        set8051Reset(true);
        download8051RAM(0, fwBuffer);
        set8051Reset(false);
    }

    /**
     * Downloads firmware to FX2 RAM. adapted from John Arthur's example in
     * Kwabena Boahen's lab at Stanford, which comes from Cypress example.
     * Firmware file is a binary file produced by uVision2 (Keil) from source
     * code for firmware.
     * <p>
     * Firmware that is actually downloaded depends on discovered PID of device.
     * If the PID is discovered to be a bare CypressFX2, then a dialog is shown
     * that user can use to program the VID/PID of the device.
     * <p>
     * In addition, there is a problem if firmware is downloaded more than once
     * to an FX2LP device between hard resets. Therefore if this method detects
     * that the device has string identifiers, it assumes the firmware has
     * already been downloaded.
     *
     * <p>
     * Firmware file is loaded either from the file system or as a resource from
     * the jar archive.
     *
     * @throws BlankDeviceException if device is blank or firmware file is not
     * found.
     * @throws HardwareInterfaceException if there is an error during download
     */
    public synchronized void downloadFirmwareBinaryToBlankDevice() throws HardwareInterfaceException {

        //  firmware load variables
        byte[] fwBuffer; // buffer to hold contents of firmware file (binary 8051 code)

        //        String firmwareFilename = getFirmwareFilenameBinaryFromVIDPID();
        String firmwareFilename = getChip() == null ? null : getChip().getDefaultFirmwareBixFileForBlankDevice();
        if (firmwareFilename == null) {
//            log.warning("firmwareFilename=null, please set a default binary firmware file for RAM download");
            throw new BlankDeviceException("firmwareFilename=null, please set a default binary firmware file for RAM download");
        }

        log.info("downloading binary firmware " + firmwareFilename + " to CypressFX2 RAM (volatile, on-chip) memory");
        try {
            fwBuffer = loadBinaryFirmwareFile(firmwareFilename);
        } catch (IOException e) {
            close();
            log.warning(e.getMessage());
            throw new BlankDeviceException("can't load binary Cypress FX2 firmware file " + firmwareFilename);
        }

        set8051Reset(true);
        download8051RAM(0, fwBuffer);
        set8051Reset(false);

    }

    /**
     * Returns the firmware filenmae corresponding to a VID/PID pair. This
     * filename is a full path to a resource on the classpath which is in the
     * project jar jAER.jar.
     *
     * @deprecated not used anymore - user chooses firmware file via
     * AEViewer/CypressFX2 menu item
     */
    @Deprecated
    protected String getFirmwareFilenameBinaryFromVIDPID() {
        final String defaultResource = FIRMWARE_FILENAME_TCVS320_BIX;
        String firmwareFilename = null;
        if (getPID() == PID_USBAERmini2_without_firmware) {
            firmwareFilename = FIRMWARE_FILENAME_MONITOR_SEQUENCER;
        } else if (getPID() == PID_USBAERmini2) {
            firmwareFilename = FIRMWARE_FILENAME_MONITOR_SEQUENCER;
        } else if (getPID() == PID_TCVS320_RETINA) {
            firmwareFilename = FIRMWARE_FILENAME_TCVS320_BIX;
        } else if (getPID() == PID_TMPDIFF128_RETINA) {
            firmwareFilename = FIRMWARE_FILENAME_TMPDIFF128_BIX;
        } else {
            log.warning("unknown device product ID (PID)=" + HexString.toString(getPID()));
            firmwareFilename = FIRMWARE_FILENAME_MONITOR_SEQUENCER;
//            firmwareFilename=showFirmwareFilenameDialog();
        }
        return firmwareFilename;
    }

    /**
     * Shows a dialog to let user choose a firmware file for download to the
     * device
     *
     * @return full path to chosen file
     */
    public String showFirmwareFilenameDialog() {
        String filename = null;
        CypressFX2FirmwareFilennameChooserOkCancelDialog dialog = new CypressFX2FirmwareFilennameChooserOkCancelDialog(chip != null ? chip.getAeViewer() : null, true, chip);
        dialog.setVisible(true);
        int ret = dialog.getReturnStatus();
        if (ret == CypressFX2FirmwareFilennameChooserOkCancelDialog.RET_OK) {
            filename = dialog.getChosenFile();
        } else {
            filename = null;
        }
        return filename;
//        FilenameGetter filenameGetter = new FilenameGetter();
//        try {
//            SwingUtilities.invokeAndWait(filenameGetter);
//        } catch (Exception e){
//            log.warning(e.toString());
//            return null;
//        }
//        return filenameGetter.filename;
    }

//    private class FilenameGetter implements Runnable {
//
//        String filename = null;
//
//        public void run() {
//            CypressFX2FirmwareFilennameChooserOkCancelDialog dialog = new CypressFX2FirmwareFilennameChooserOkCancelDialog(chip != null ? chip.getAeViewer() : null, true);
//            dialog.setVisible(true);
//            int ret = dialog.getReturnStatus();
//            if (ret == CypressFX2FirmwareFilennameChooserOkCancelDialog.RET_OK) {
//                filename = dialog.getChosenFile();
//            } else {
//                filename = null;
//            }
//        }
//    }
    // returns the firmware filenmae corresponding to a VID/PID pair
    // this filename is actually a full path to a resource on the classpath
    protected String getFirmwareFilenameHexFromVIDPID() {
        String firmwareFilename = null;
        if (getPID() == PID_USBAERmini2_without_firmware) {
            firmwareFilename = FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX;
        } else {
            firmwareFilename = FIRMWARE_FILENAME_TMPDIFF128_HEX;
        }
        return firmwareFilename;
    }

    /**
     * Downloads to RAM on FX2 using built-in vendor request to CPUCS. Remember
     * to set8051Reset() before and after calling this method.
     *
     * @param address the starting address in the 8051 RAM
     * @param FWBuffer the data
     * @see #set8051Reset
     */
    protected void download8051RAM(int address, final byte[] FWBuffer)
            throws HardwareInterfaceException {
        log.info("downloading " + FWBuffer.length + " bytes to CypressFX2 RAM starting at " + address);
        /* From Fx2 tech ref guide, chapter 2 "endpoint 0"
         *
         *The USB endpoint-zero protocol provides a mechanism for mixing
         vendor-specific requests with standard device requests. Bits 6:5 of the bmRequestType
         field are set to 00 for a standard device request and to 10 for a vendor request.
         **/
        // need to perform the following steps:
        //
        //	1) reset the Cypress (write 0x01 into CPUCS register)
        //	2) send the firmware to Control Endpoint 0
        //	3) pull the Cypress out of reset (write 0x00 into the CPUCS register)

        // this is achieved by using the vendor request VENDOR_REQUEST_FIRMWARE, where the Value of the request is the
        // address to write to and the buffer passed to USBIO_CLASS_OR_VENDOR_REQUEST defines data to be written
        // starting at this address and the number of bytes to be written.
        // thus the same vendor request can reset the 8051 (one byte written to CPUCS) and download successive chunks
        // of code. finally the request can unreset the 8051.
        int result;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();
        USBIO_DATA_BUFFER dataBuffer;
        int fwIndex;
        int numChunks;

        vendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type = UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient = UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits = 0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Request = VENDOR_REQUEST_FIRMWARE; // this is download/upload firmware request. really it is just a 'fill RAM request'
        vendorRequest.Index = 0;

        //	2) send the firmware to Control Endpoint 0
        // when sending firmware, we need to break up the loaded fimware
        //		into MAX_CONTROL_XFER_SIZE blocks
        //
        // this means:
        //	a) the address to load it to needs to be changed (VendorRequest.Value)
        //	b) need a pointer that moves through FWbuffer (pBuffer)
        //	c) keep track of remaining bytes to transfer (FWsize_left);
        //send all but last chunk
        vendorRequest.Value = 0;			//address of firmware location
        dataBuffer = new USBIO_DATA_BUFFER(MAX_CONTROL_XFER_SIZE);
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        fwIndex = 0;
        numChunks = FWBuffer.length / MAX_CONTROL_XFER_SIZE;  // this is number of full chunks to send
        for (int i = 0; i < numChunks; i++) {
            System.arraycopy(FWBuffer, i * MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, MAX_CONTROL_XFER_SIZE);
            result = gUsbIo.classOrVendorOutRequest(dataBuffer, vendorRequest);
            if (result != USBIO_ERR_SUCCESS) {
                close();
                throw new HardwareInterfaceException("Error on downloading segment number " + i + " of 8051 firmware: " + UsbIo.errorText(result));
            }
            vendorRequest.Value += MAX_CONTROL_XFER_SIZE;			//change address of firmware location
        }

        // now send final (short) chunk
        int numBytesLeft = FWBuffer.length % MAX_CONTROL_XFER_SIZE;  // remainder
        if (numBytesLeft > 0) {
            dataBuffer = new USBIO_DATA_BUFFER(numBytesLeft);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
            System.arraycopy(FWBuffer, numChunks * MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, numBytesLeft);

            // send remaining part of firmware
            result = gUsbIo.classOrVendorOutRequest(dataBuffer, vendorRequest);
            if (result != USBIO_ERR_SUCCESS) {
                close();
                throw new HardwareInterfaceException("Error on downloading final segment of 8051 firmware: " + UsbIo.errorText(result));
            }
        }
        log.info("done downloading RAM");
    }

    /**
     * sends vendor request to CPUCS register to set 8051 in CPU reset (or not)
     *
     * @param value true to reset, false to run
     * @see #download8051RAM
     */
    protected void set8051Reset(boolean value) throws HardwareInterfaceException {

//        log.info("setting 8051 reset="+value);
        int result;
        USBIO_DATA_BUFFER dataBuffer;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest;
        // make vendor request structure and populate it
        vendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        vendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type = UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient = UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits = 0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Request = VENDOR_REQUEST_FIRMWARE; // this is download/upload firmware request. really it is just a 'fill RAM request'
        vendorRequest.Index = 0;

        //	1) reset the Cypress (write 0x01 into CPUCS register)
        vendorRequest.Value = CPUCS; // we're writing to this RAM address, which is actually the only register that the host can write to
        dataBuffer = new USBIO_DATA_BUFFER(1); // make a new buffer to define the length of the request data correctly
        dataBuffer.Buffer()[0] = (byte) (value ? 1 : 0);            // 1 to reset, 0 to run
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        result = gUsbIo.classOrVendorOutRequest(dataBuffer, vendorRequest);
        if (result != USBIO_ERR_SUCCESS) {
            close();
            throw new HardwareInterfaceException("Unable to reset 8051 for firmware download: " + UsbIo.errorText(result));
        }

    }

    /**
     * @return timestamp tick in us NOTE: DOES NOT RETURN THE TICK OF THE
     * USBAERmini2 board
     */
    @Override
    final public int getTimestampTickUs() {
        return TICK_US;
    }

    /**
     * returns last events from {@link #acquireAvailableEventsFromDriver}
     *
     * @return the event packet
     */
    @Override
    public AEPacketRaw getEvents() {
        return this.lastEventsAcquired;
    }

    /**
     * sends a vender request without data, value and index are set to zero.
     * This is a blocking method.
     *
     * The SETUPDAT array on FX2 has the following 8 elements (see FX2 TRM
     * Section 2.3)<br>
     * SETUPDAT[0] VendorRequest 0x40 for OUT type, 0xC0 for IN type<br>
     * SETUPDAT[1] The actual vendor request (e.g. VR_ENABLE_AE_IN below)<br>
     * SETUPDAT[2] wValueL 16 bit value LSB<br>
     * 3 wValueH MSB<br>
     * 4 wIndexL 16 bit field, varies according to request<br>
     * 5 wIndexH<br>
     * 6 wLengthL Number of bytes to transfer if there is a data phase<br>
     * 7 wLengthH<br>
     *
     * @param request the vendor request byte, identifies the request on the
     * device
     */
    synchronized public void sendVendorRequest(byte request) throws HardwareInterfaceException {
        sendVendorRequest(request, (short) 0, (short) 0, new byte[0]);
    }

    /**
     * sends a vender request without any data packet but with request, value
     * and index. This is a blocking method.
     *
     * The SETUPDAT array on FX2 has the following 8 elements (see FX2 TRM
     * Section 2.3)<br>
     * SETUPDAT[0] VendorRequest 0x40 for OUT type, 0xC0 for IN type. We do not
     * set this value.<br>
     * SETUPDAT[1] The actual vendor request (e.g. VR_ENABLE_AE_IN below)<br>
     * SETUPDAT[2] wValueL 16 bit value LSB<br>
     * SETUPDAT[3] wValueH MSB<br>
     * SETUPDAT[4] wIndexL 16 bit field, varies according to request<br>
     * SETUPDAT[5] wIndexH<br>
     * SETUPDAT[6] wLengthL Number of bytes to transfer if there is a data
     * phase<br>
     * SETUPDAT[7] wLengthH<br>
     *
     * <p>
     * In firmware, the code looks like this:<br>
     * value = SETUPDAT[2];	// Get request value<br>
     * value |= SETUPDAT[3] << 8;	// data comes little endian<br> ind =
     * SETUPDAT[4];	// Get index<br>
     * ind |= SETUPDAT[5] << 8;<br> len = SETUPDAT[6]; // length for data
     * phase<br>
     * len |= SETUPDAT[7] << 8;<br>
     *
     * @param request the vendor request byte, identifies the request on the
     * device
     * @param value the value of the request (bValue USB field)
     * @param index the "index" of the request (bIndex USB field)
     */
    synchronized public void sendVendorRequest(byte request, short value, short index) throws HardwareInterfaceException {
        sendVendorRequest(request, value, index, new MyUsbioDataBuffer(new byte[0]));
    }

    private class MyUsbioDataBuffer extends USBIO_DATA_BUFFER {

        MyUsbioDataBuffer(byte[] b) {
            super(b.length);
            System.arraycopy(b, 0, bufferarray, 0, b.length);
            setNumberOfBytesToTransfer(b.length);
        }
    }

    /**
     * Sends a vendor request with a given byte[]. This is a blocking method.
     *
     * The SETUPDAT array on FX2 has the following 8 elements (see FX2 TRM
     * Section 2.3)<br>
     * SETUPDAT[0] VendorRequest 0x40 for OUT type, 0xC0 for IN type<br>
     * SETUPDAT[1] The actual vendor request (e.g. VR_ENABLE_AE_IN below)<br>
     * SETUPDAT[2] wValueL 16 bit value LSB<br>
     * 3 wValueH MSB<br>
     * 4 wIndexL 16 bit field, varies according to request<br>
     * 5 wIndexH<br>
     * 6 wLengthL Number of bytes to transfer if there is a data phase<br>
     * 7 wLengthH<br>
     *
     * @param request the vendor request byte, identifies the request on the
     * device
     * @param value the value of the request (bValue USB field)
     * @param index the "index" of the request (bIndex USB field)
     * @param bytes the data which is to be transmitted to the device
     * @throws net.sf.jaer.hardwareinterface.HardwareInterfaceException
     */
    synchronized public void sendVendorRequest(byte request, short value, short index, byte[] bytes) throws HardwareInterfaceException {
        MyUsbioDataBuffer dataBuffer = new MyUsbioDataBuffer(bytes);
        sendVendorRequest(request, value, index, dataBuffer);
    }

    /**
     * sends a vender request with data. This is a blocking method.
     *
     * The SETUPDAT array on FX2 has the following 8 elements (see FX2 TRM
     * Section 2.3)<br>
     * SETUPDAT[0] VendorRequest 0x40 for OUT type, 0xC0 for IN type<br>
     * SETUPDAT[1] The actual vendor request (e.g. VR_ENABLE_AE_IN below)<br>
     * SETUPDAT[2] wValueL 16 bit value LSB<br>
     * 3 wValueH MSB<br>
     * 4 wIndexL 16 bit field, varies according to request<br>
     * 5 wIndexH<br>
     * 6 wLengthL Number of bytes to transfer if there is a data phase<br>
     * 7 wLengthH<br>
     *
     * @param request the vendor request byte, identifies the request on the
     * device
     * @param value the value of the request (bValue USB field)
     * @param index the "index" of the request (bIndex USB field)
     * @param dataBuffer the data which is to be transmitted to the device
     */
    synchronized public void sendVendorRequest(byte request, short value, short index, USBIO_DATA_BUFFER dataBuffer) throws HardwareInterfaceException {
        if (!isOpen()) {
            open();
        }

        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();
        int status;

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = request;
        VendorRequest.Index = index;
        VendorRequest.Value = value;

//        System.out.println("request= " + request + " value: " + value);
        if (dataBuffer == null) {
            dataBuffer = new USBIO_DATA_BUFFER(1);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        } else {
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        }

        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);

        if (status != USBIO_ERR_SUCCESS) {
            throw new HardwareInterfaceException("Unable to send vendor request " + String.format("0x%x", request) + ": " + UsbIo.errorText(status));
        }

        HardwareInterfaceException.clearException();
    }
    /* encodings of xsvf instructions */
    private static final byte XCOMPLETE = (byte) 0;
    private static final byte XTDOMASK = (byte) 1;
    private static final byte XSIR = (byte) 2;
    private static final byte XSDR = (byte) 3;
    private static final byte XRUNTEST = (byte) 4;
    /* Reserved              5 */
 /* Reserved              6 */
    private static final byte XREPEAT = (byte) 7;
    private static final byte XSDRSIZE = (byte) 8;
    private static final byte XSDRTDO = (byte) 9;
    private static final byte XSDRB = (byte) 12;
    private static final byte XSDRC = (byte) 13;
    private static final byte XSDRE = (byte) 14;
    private static final byte XSDRTDOB = (byte) 15;
    private static final byte XSDRTDOC = (byte) 16;
    private static final byte XSDRTDOE = (byte) 17;
    private static final byte XSTATE = (byte) 18;
    /* 4.00 */

    private static final byte XENDIR = (byte) 19;
    /* 4.04 */

    private static final byte XENDDR = (byte) 20;
    /* 4.04 */

    private static final byte XSIR2 = (byte) 21;
    /* 4.10 */

    private static final byte XCOMMENT = (byte) 22;
    /* 4.14 */

    private static final byte XWAIT = (byte) 23;

    /* 5.00 */


    /**
     * Writes the CPLD configuration from an SVF file. Thread-safe.
     *
     * @param svfFile
     * @throws net.sf.jaer.hardwareinterface.HardwareInterfaceException
     */
    synchronized public void writeCPLDfirmware(String svfFile) throws HardwareInterfaceException {
        byte[] bytearray;
        byte command;
        int commandlength = 1, index = 0, length = 0, status;
        USBIO_DATA_BUFFER dataBuffer = null;
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest;

        try {
            bytearray = this.loadBinaryFirmwareFile(svfFile);
        } catch (Exception e) {
            e.printStackTrace();
            return;
        }
        ProgressMonitor progressMonitor = makeProgressMonitor("Writing CPLD configuration - do not unplug", 0, bytearray.length);

        if ((bytearray == null) || (bytearray.length == 0)) {
            throw new NullPointerException("xsvf file seems to be empty. Did ISE compile it and did you generate the XSVF file?");
        }
        command = bytearray[index];

        while (command != 0x00) {
            commandlength = 1;
            switch (command) {
                case XTDOMASK:
                    commandlength = length + 1;
                    break;
                case XREPEAT:
                    commandlength = 2;
                    break;
                case XRUNTEST:
                    commandlength = 5;
                    break;
                case XSIR:
                    commandlength = ((bytearray[index + 1] + 7) / 8) + 2;
                    break;
                case XSIR2:
                    commandlength = ((((bytearray[index + 1] << 8) | bytearray[index + 2]) + 7) / 8) + 3;
                    break;
                case XSDR:
                    commandlength = length + 1;
                    break;
                case XSDRSIZE:
                    commandlength = 5;
                    length = (((bytearray[index + 1] & 0xFF) << 24) | ((bytearray[index + 2] & 0xFF) << 16) | ((bytearray[index + 3] & 0xFF) << 8) | (((bytearray[index + 4]) & 0xFF) + 7)) / 8;
                    break;
                case XSDRTDO:
                    commandlength = (2 * length) + 1;
                    break;
                case XSDRB:

                    commandlength = length + 1;
                    break;
                case XSDRC:

                    commandlength = length + 1;
                    break;
                case XSDRE:

                    commandlength = length + 1;
                    break;
                case XSDRTDOB:

                    commandlength = (2 * length) + 1;
                    break;
                case XSDRTDOC:

                    commandlength = (2 * length) + 1;
                    break;
                case XSDRTDOE:

                    commandlength = (2 * length) + 1;
                    break;
                case XSTATE:

                    commandlength = 2;
                    break;
                case XENDIR:

                    commandlength = 2;
                    break;
                case XENDDR:

                    commandlength = 2;
                    break;
                case XCOMMENT:

                    commandlength = 2;
                    while (bytearray[(index + commandlength) - 1] != 0x00) {
                        commandlength += 1;
                    }
                    log.info("found comment");
                    break;
                case XWAIT:

                    commandlength = 7;
                    break;
                default:
                    this.sendVendorRequest(VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0);
                    throw new HardwareInterfaceException("Unable to program CPLD, unknown xsfv command: " + command);
            }
            //System.out.println("command: " + command + " index: " + index + " commandlength " + commandlength);
            //        System.out.println("max command length " + maxlen);

            dataBuffer = new USBIO_DATA_BUFFER(commandlength);
            System.arraycopy(bytearray, index, dataBuffer.Buffer(), 0, commandlength);

//            if (index==84700)
//            {
//                byte bt;
//
////                for (int ki=0; ki<commandlength;ki++)
////                {
////                    bt=bytearray[index+ki];
////                    System.out.println(Integer.toHexString(bt));
////                }
//
//                for (int ki=0; ki<10;ki++)
//                {
//                    bt=bytearray[index+ki+commandlength-4];
//                    System.out.println(Integer.toHexString(bt));
//                }
//
//            }
            this.sendVendorRequest(VR_DOWNLOAD_FIRMWARE, command, (short) 0, dataBuffer);

            VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();
            dataBuffer = new USBIO_DATA_BUFFER(2);

            VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
            VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
            VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
            VendorRequest.RequestTypeReservedBits = 0;
            VendorRequest.Request = VR_DOWNLOAD_FIRMWARE;
            VendorRequest.Index = 0;
            VendorRequest.Value = 0;

            dataBuffer.setNumberOfBytesToTransfer(2);
            status = gUsbIo.classOrVendorInRequest(dataBuffer, VendorRequest);

            if (status != USBIO_ERR_SUCCESS) {
                throw new HardwareInterfaceException("Unable to receive xsvf error code: " + UsbIo.errorText(status));
            }

            HardwareInterfaceException.clearException();

            // log.info("bytes transferred" + dataBuffer.getBytesTransferred());
            if (dataBuffer.getBytesTransferred() == 0) {
                this.sendVendorRequest(VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0);
                throw new HardwareInterfaceException("Unable to program CPLD, could not get xsvf Error code");
            }
            if (dataBuffer.Buffer()[1] == 10) {
                this.sendVendorRequest(VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0);
                throw new HardwareInterfaceException("Unable to program CPLD, command too long, please report to raphael@ini.ch, command: " + command + " index: " + index + " commandlength " + commandlength);
            } else if (dataBuffer.Buffer()[1] > 0) {
                this.sendVendorRequest(VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0);
                throw new HardwareInterfaceException("Unable to program CPLD, error code: " + dataBuffer.Buffer()[1] + ", at command: " + command + " index: " + index + " commandlength " + commandlength);
                // System.out.println("Unable to program CPLD, unable to program CPLD, error code: " + dataBuffer.Buffer()[1] + ", at command: " + command + " index: " + index + " commandlength " + commandlength);
            }

            index += commandlength;
            command = bytearray[index];
            // can't cancel
            if (progressMonitor.isCanceled()) {
                progressMonitor = makeProgressMonitor("Writing CPLD configuration - do not unplug", 0, bytearray.length);
            }
            progressMonitor.setProgress(index);
            progressMonitor.setNote(String.format("sent %d of %d bytes of CPLD configuration", index, bytearray.length));
        } //complete

        log.info("sending XCOMPLETE");
        this.sendVendorRequest(VR_DOWNLOAD_FIRMWARE, XCOMPLETE, (short) 0);
        progressMonitor.close();

    }

    public AEReader getAeReader() {
        return aeReader;
    }

    public void setAeReader(AEReader aeReader) {
        this.aeReader = aeReader;
    }

    @Override
    public int getFifoSize() {
        if (aeReader == null) {
            return -1;
        } else {
            return aeReader.getFifoSize();
        }
    }

    @Override
    public void setFifoSize(int fifoSize) {
        if (aeReader == null) {
            return;
        }
        aeReader.shutdownThread();
        aeReader.setFifoSize(fifoSize);
        aeReader.startThread(3);
    }

    @Override
    public int getNumBuffers() {
        if (aeReader == null) {
            return 0;
        } else {
            return aeReader.getNumBuffers();
        }
    }

    @Override
    public void setNumBuffers(int numBuffers) {
        if (aeReader == null) {
            return;
        }
        aeReader.shutdownThread();
        aeReader.setNumBuffers(numBuffers);
        aeReader.startThread(3);
    }

    @Override
    public void setChip(AEChip chip) {
        this.chip = chip;
    }

    @Override
    public AEChip getChip() {
        return chip;
    }

    /**
     * Resets the USB device using USBIO resetDevice
     */
    public void resetUSB() {
        if (gUsbIo == null) {
            return;
        }
        int status = gUsbIo.resetDevice();
        if (status != 0) {
            log.warning("Error resetting device: " + UsbIo.errorText(status));
        }
    }

    /**
     * Cycles the port using USBIO cyclePort. Does nothing if device has not
     * been instantiated.
     */
    public void cyclePort() throws HardwareInterfaceException {
        if (gUsbIo == null) {
            return;
        }
        int status = gUsbIo.cyclePort();
        if (status != 0) {
            throw new HardwareInterfaceException("Error cycling port: " + UsbIo.errorText(status));
        }
    }

    /**
     * Checks for blank cypress VID/PID. Device deviceDescriptor must be
     * populated before calling this method.
     *
     * @return true if blank
     */
    protected boolean isBlankDevice() {
        if ((deviceDescriptor.idVendor == VID_BLANK) && (deviceDescriptor.idProduct == PID_BLANK)) {
//            log.warning("blank CypressFX2 detected");
            return true;
        }
        return false;
    }

    public void setShowUsbStatistics(boolean yes) {
        usbPacketStatistics.setShowUsbStatistics(yes);
    }

    public void setPrintUsbStatistics(boolean yes) {
        usbPacketStatistics.setPrintUsbStatistics(yes);
    }

    public boolean isShowUsbStatistics() {
        return usbPacketStatistics.isShowUsbStatistics();
    }

    public boolean isPrintUsbStatistics() {
        return usbPacketStatistics.isPrintUsbStatistics();
    }

}
