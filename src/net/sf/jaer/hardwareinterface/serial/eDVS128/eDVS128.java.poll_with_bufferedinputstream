/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package net.sf.jaer.hardwareinterface.serial.eDVS128;

import java.io.*;
import java.net.*;
import java.beans.*;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.prefs.*;
import java.nio.channels.DatagramChannel;


import net.sf.jaer.aemonitor.*;
import net.sf.jaer.chip.*;
import net.sf.jaer.eventio.*;
import net.sf.jaer.biasgen.*;
import net.sf.jaer.hardwareinterface.*;
import net.sf.jaer.hardwareinterface.serial.*;
import ch.unizh.ini.jaer.projects.einsteintunnel.multicamera.*;

import gnu.io.CommPort;
import gnu.io.CommPortIdentifier;
import gnu.io.SerialPort;
import java.io.BufferedInputStream;

import org.apache.commons.io.IOUtils.*;

import java.io.FileDescriptor;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import java.lang.Math.*;
import org.apache.commons.io.IOUtils;

/**
 *
 * @author lou
 */
public class eDVS128 implements SerialInterface, HardwareInterface, AEMonitorInterface, BiasgenHardwareInterface {

    protected static Preferences prefs = Preferences.userNodeForPackage(eDVS128.class);
    public PropertyChangeSupport support = new PropertyChangeSupport(this);
    protected Logger log = Logger.getLogger("eDVS128");
    protected AEChip chip;
    public final short TICK_US = 1;
    protected AEPacketRaw lastEventsAcquired = new AEPacketRaw();
    public static final int AE_BUFFER_SIZE = 100000; // should handle 5Meps at 30FPS
    protected int aeBufferSize = prefs.getInt("eDVS128.aeBufferSize", AE_BUFFER_SIZE);
    protected int interfaceNumber = 0;
    public static boolean isOpen = false;
    public static boolean eventAcquisitionEnabled = false;
    public static boolean overrunOccuredFlag = false;
    protected byte cHighBitMask = (byte) 0x80;
    protected byte cLowerBitsMask = (byte) 0x7F;
    int eventCounter = 0;
    int bCalibrated = 0;
    protected String devicName;
    protected InputStream retina; //BufferedInputStream
    protected OutputStream retinaVendor;
    public final PropertyChangeEvent NEW_EVENTS_PROPERTY_CHANGE = new PropertyChangeEvent(this, "NewEvents", null, null);
    protected AEPacketRawPool aePacketRawPool = new AEPacketRawPool();

    //AEUnicastInput input = null;
    //InetSocketAddress client = null;
    public eDVS128(String deviceName) throws FileNotFoundException {
        //this.inRecvBufterfaceNumber = devNumber;
        try {
            CommPortIdentifier portIdentifier = CommPortIdentifier.getPortIdentifier(deviceName);

            if (portIdentifier.isCurrentlyOwned()) {
                System.out.println("Error: Port is currently in use");
            } else {
                CommPort commPort = portIdentifier.open(this.getClass().getName(), 2000);

                if (commPort instanceof SerialPort) {
                    SerialPort serialPort = (SerialPort) commPort;
                    serialPort.setSerialPortParams(4000000, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);
                    serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN);
                    serialPort.setFlowControlMode(serialPort.FLOWCONTROL_RTSCTS_OUT);

                    retina = serialPort.getInputStream();
                    retinaVendor = serialPort.getOutputStream();

                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }


    }

    @Override
    public void open() throws HardwareInterfaceException {

        if (!isOpen) {
            try {


                String s = "!E1\n";
                byte[] b = s.getBytes();
                retinaVendor.write(b, 0, 4);

                s = "E+\n";
                b = s.getBytes();
                retinaVendor.write(b, 0, 3);

                isOpen = true;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        /*
        if (!isOpen){
        try{
        if ( input != null ){
        input.close();
        }
        
        input = new AEUnicastInput(STREAM_PORT);
        input.setSequenceNumberEnabled(false);
        input.setAddressFirstEnabled(true);
        input.setSwapBytesEnabled(true);
        input.set4ByteAddrTimestampEnabled(true);
        input.setTimestampsEnabled(true);
        input.setLocalTimestampEnabled(true);
        input.setBufferSize(1200);
        input.setTimestampMultiplier(0.001f);
        input.open();
        isOpen = true;
        } catch ( IOException ex ){
        throw new HardwareInterfaceException(ex.toString());
        }
        }*/


    }

    @Override
    public boolean isOpen() {
        return true;
    }

    @Override
    public void close() {
        try {
            String s = "E-\n";
            byte[] b = s.getBytes();
            retinaVendor.write(b, 0, 3);
            isOpen = false;

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public String getTypeName() {
        return "eDVS128";
    }

    @Override
    public void setChip(AEChip chip) {
        this.chip = chip;
        //host = "localhost";
        //port = STREAM_PORT;
        //host = chip.getPrefs().get("ATIS304.host","172.25.48.35"); // "localhost"
        //port = chip.getPrefs().getInt("controlPort",CONTROL_PORT);
    }

    @Override
    public AEChip getChip() {
        return chip;
    }

    @Override
    final public int getTimestampTickUs() {
        return TICK_US;
    }
    private int estimatedEventRate = 0;

    @Override
    public int getEstimatedEventRate() {
        return estimatedEventRate;
    }

    @Override
    public int getMaxCapacity() {
        return 156250000;
    }

    @Override
    public void addAEListener(AEListener listener) {
        support.addPropertyChangeListener(listener);
    }

    @Override
    public void removeAEListener(AEListener listener) {
        support.removePropertyChangeListener(listener);
    }

    @Override
    public void setEventAcquisitionEnabled(boolean enable) throws HardwareInterfaceException {
        if (enable) {
            //startAer();
            startAEReader();
        } else {
            //stopAer();
            stopAEReader();
        }
    }

    @Override
    public boolean isEventAcquisitionEnabled() {
        return eventAcquisitionEnabled;
    }

    @Override
    public int getAEBufferSize() {
        return aeBufferSize; // aePacketRawPool.writeBuffer().getCapacity();
    }

    @Override
    public void setAEBufferSize(int size) {
        if (size < 1000 || size > 1000000) {
            log.warning("ignoring unreasonable aeBufferSize of " + size + ", choose a more reasonable size between 1000 and 1000000");
            return;
        }
        this.aeBufferSize = size;
        prefs.putInt("eDVS128.aeBufferSize", aeBufferSize);
    }

    @Override
    public boolean overrunOccurred() {
        return overrunOccuredFlag;
    }

    /** Resets the timestamp unwrap value, resets the USBIO pipe, and resets the AEPacketRawPool.
     */
    @Override
    synchronized public void resetTimestamps() {
        //TODO call TDS to reset timestamps
    }

    /** returns last events from {@link #acquireAvailableEventsFromDriver}
     *@return the event packet
     */
    @Override
    public AEPacketRaw getEvents() {
        return this.lastEventsAcquired;
    }

    /** Returns the number of events acquired by the last call to {@link
     * #acquireAvailableEventsFromDriver }
     * @return number of events acquired
     */
    @Override
    public int getNumEventsAcquired() {
        return lastEventsAcquired.getNumEvents();
    }

    @Override
    public AEPacketRaw acquireAvailableEventsFromDriver() throws HardwareInterfaceException {
        if (!eventAcquisitionEnabled) {
            setEventAcquisitionEnabled(true);
        }
        int nEvents;
        aePacketRawPool.swap();
        lastEventsAcquired = aePacketRawPool.readBuffer();
        nEvents = lastEventsAcquired.getNumEvents();
        eventCounter = 0;
        computeEstimatedEventRate(lastEventsAcquired);

        if (nEvents != 0) {
            support.firePropertyChange(NEW_EVENTS_PROPERTY_CHANGE); // call listeners  
        }

        return lastEventsAcquired;
    }

    synchronized public void vendorRequest(int cmd) {
        try {
            switch (cmd) {
                case 1:
                    byte[] command = new byte[]{'E', '+', '\r', '\n'};
                    retinaVendor.write(command, 0, 4);
                    break;

                case 2:
                    //byte[] command = new byte[]{'E','-','\n'};
                    //retinaVendor.write(command,0,3);         
                    break;


            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /** computes the estimated event rate for a packet of events */
    void computeEstimatedEventRate(AEPacketRaw events) {
        if (events == null || events.getNumEvents() < 2) {
            estimatedEventRate = 0;
        } else {
            int[] ts = events.getTimestamps();
            int n = events.getNumEvents();
            int dt = ts[n - 1] - ts[0];
            estimatedEventRate = (int) (1e6f * (float) n / (float) dt);
        }
    }

    @Override
    public void setPowerDown(boolean powerDown) {
        log.warning("Power down not supported by eDVS128 devices.");
    }

    @Override
    public void sendConfiguration(Biasgen biasgen) throws HardwareInterfaceException {
    }

    @Override
    public void flashConfiguration(Biasgen biasgen) {
        log.warning("Flash configuration not supported by eDVS128 devices.");
    }

    @Override
    public byte[] formatConfigurationBytes(Biasgen biasgen) {
        throw new UnsupportedOperationException("Not supported yet.");// TODO use this to send all biases at once?
    }

    @Override
    public String toString() {
        return "Serial: eDVS128";
    }
    protected boolean running = true;
    final int WRAP_START = 0; //(int)(0xFFFFFFFFL&(2147483648L-0x400000L)); // set high to test big wrap 1<<30;
    volatile int wrapAdd = WRAP_START; //0;
    protected AEReader aeReader = null;

    public AEReader getAeReader() {
        return aeReader;
    }

    public void setAeReader(AEReader aeReader) {
        this.aeReader = aeReader;
    }

    public void startAEReader() {
        setAeReader(new AEReader(this));
        log.info("Start AE reader...");
        getAeReader().start();
        eventAcquisitionEnabled = true;
    }

    public void stopAEReader() {
        if (getAeReader() != null) {
            // close device
            getAeReader().finish();
            setAeReader(null);
            releaseInterface();
        }
    }

    synchronized void claimInterface() {
    }

    synchronized public void releaseInterface() {
    }

    public class RecvBuf extends BufferedInputStream{
        protected InputStream in;
        
        public RecvBuf(InputStream in){
            super (in, 8192);
            this.in = in;
        }
        
        public synchronized int read(byte b[], int len) throws IOException
        {    
   
            int length = super.read(b, 0, len);
           
            //System.out.println(length + " " +  pos + " " + count); 
            int tail = length%4;
            //System.out.println("pos: "+  super.pos + " length: " + length + " tail: " + tail);           
     
            //super.pos = super.pos + length;
             
            if (tail != 0){
                if (pos >= tail ){
                   pos = pos - tail;
                } else {  
                    pos = pos + (4 - tail);
                    //System.out.println(pos + "/" + tail);
                    //pos = 8192  + pos - tail; 
                    System.out.println(length + " " + pos );
                }
            }

            //System.out.println("=> new pos: " + pos);
            return length - tail;
        }    
    }
     
    
    public class AEReader extends Thread implements Runnable {

        private byte[] buffer = null;
        eDVS128 monitor;

        public AEReader(eDVS128 monitor) {
            this.monitor = monitor;
            /* This is a list of all this interface's endpoints. */
            allocateAEBuffers();

            buffer = new byte[8192];//UsbUtil.unsignedInt(usbPipe.getUsbEndpoint().getUsbEndpointDescriptor().wMaxPacketSize())];
        }

        public void run() {

            int offset = 2;
            int length = 0;
            int len = 0;
            int nDump = 0;
            RecvBuf _retina = new RecvBuf(retina);
            
            while (running) {    
                try {
                    length = _retina.read(buffer, 8192);
               
                } catch (IOException e) {
                        e.printStackTrace();                    
                }
                    

             if (length > 0) {
                  System.out.println(length);               
                    nDump = 0;

                    if (bCalibrated == 0) {                    
                        offset = 2;
                        int diff = 0;
                        if (length > 230) {
                            //System.out.println("diff");
                            int diff_min = 100000;
                            for (int i = 0; i <= 3; i++) {
                                //offset=i;
                                diff = 0;
                                for (int m = 0; m < 50; m++) {
                                    diff += (int) (buffer[4 * (m + 1) + i] - buffer[4 * m + i] ) * (int) (buffer[4 * (m + 1) + i] - buffer[4 * m + i]);
                                }
                                //System.out.println(diff);
                                
                                if (diff < diff_min) { //10
                                    diff_min = diff;
                                    offset = i;
                                    //break;
                                }   
                            }
                            //System.out.println("====" + offset);
                        }

                        //System.out.println("length: " + length + " tail: " + nTail + " offset: " + offset);
          
                        switch (offset) {
                            case 0:
                                nDump = 2;
                                break;
                            case 1:
                                nDump = 3;
                                break;
                            case 2:
                                nDump = 0;
                                break;
                            case 3:
                                nDump = 1;
                                break;
                            default:
                                log.info("Achtung, error");
                        }

                        if (nDump != 0) {
                            long length1 = 0;
                            long len1 = 0;
                            try {
                                while (length1 != nDump) {
                                    //len = retina.read(buffer, length1, nDump - length1);
                                    len1 = retina.skip(nDump-length1);
                                    length1 = length1 + len1;
                                }
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            //log.info("Dumped: " + length1 + " bytes / " + nDump);
                            System.out.println("Dumped: " + length1 + " bytes / " + nDump);
                        } else {
                            bCalibrated = 1;
                            log.info("Calibrated");
                        }
                    }
                    translateEvents_code(buffer, nDump, length);

                }

                if (timestampsReset) {
                    log.info("timestampsReset: flushing aePacketRawPool buffers");
                    aePacketRawPool.reset();
                    timestampsReset = false;
                }

            }


        }

        synchronized private void submit(int BufNumber) {
        }

        /**
         * Stop/abort listening for data events.
         */
        synchronized public void finish() {
            running = false;
        }

        synchronized public void resetTimestamps() {
            log.info(eDVS128.this + ": wrapAdd=" + wrapAdd + ", zeroing it");
            wrapAdd = WRAP_START;
            timestampsReset = true; // will inform reader thread that timestamps are reset

        }
        protected boolean running = true;
        volatile boolean timestampsReset = false; // used to tell processData that another thread has reset timestamps
    }
    private int inputProcessingIndex = 0;
    private int pixelX, pixelY, pixelP;
    private String specialData;
    private int bCali = 1;

    protected void translateEvents_code(byte[] b, int offset, int bytesSent) {
        synchronized (aePacketRawPool) {
            eventCounter = 0;

            AEPacketRaw buffer = aePacketRawPool.writeBuffer();
            int shortts;
            int NumberOfWrapEvents;
            NumberOfWrapEvents = 0;

            int[] addresses = buffer.getAddresses();
            int[] timestamps = buffer.getTimestamps();

            // write the start of the packet
            buffer.lastCaptureIndex = eventCounter;

            
            for (int i = offset; i < bytesSent - (4 -offset)%4; i += 4) {
                byte y_ = b[i];
                byte x_ = b[i + 1];
                byte c_ = b[i + 2];
                byte d_ = b[i + 3];
               

//                if ( (y_ & 0x80) != 0){
//                     System.out.println("Data not aligned!");
//                }
//                if ( ((x_ & cLowerBitsMask) == 0) && ((y_ & cLowerBitsMask) == 0)){
//                   System.out.println((x_ & cLowerBitsMask) + " " + y_);
//                    continue;
//                }
                
                addresses[eventCounter] = (int)( (x_ & cHighBitMask) >> 7 | ((127 - (y_ & cLowerBitsMask)) << 8) | ( (127 - (x_ & cLowerBitsMask)) << 1) )& 0x7FFF;
                timestamps[eventCounter] = (c_ | (d_ << 8));
                //timestamps[eventCounter] =  ( (c_ << 8)  | d_ );
                eventCounter++;
                buffer.setNumEvents(eventCounter);
            }

            // write capture size
            buffer.lastCaptureLength = eventCounter - buffer.lastCaptureIndex;
        } // sync on aePacketRawPool

    }

    void allocateAEBuffers() {
        synchronized (aePacketRawPool) {
            aePacketRawPool.allocateMemory();
        }
    }

    private class AEPacketRawPool {

        int capacity;
        AEPacketRaw[] buffers;
        AEPacketRaw lastBufferReference;
        volatile int readBuffer = 0, writeBuffer = 1; // this buffer is the one currently being read from

        AEPacketRawPool() {
            allocateMemory();
            reset();
        }

        synchronized final void swap() {
            lastBufferReference = buffers[readBuffer];
            if (readBuffer == 0) {
                readBuffer = 1;
                writeBuffer = 0;
            } else {
                readBuffer = 0;
                writeBuffer = 1;
            }
            writeBuffer().clear();
            writeBuffer().overrunOccuredFlag = false; // mark new write buffer clean, no overrun happened yet. writer sets this if it happens

        }

        /** @return buffer to read from */
        synchronized final AEPacketRaw readBuffer() {
            return buffers[readBuffer];
        }

        /** @return buffer to write to */
        synchronized final AEPacketRaw writeBuffer() {
            return buffers[writeBuffer];
        }

        /** Set the current buffer to be the first one and clear the write buffer */
        synchronized final void reset() {
            readBuffer = 0;
            writeBuffer = 1;
            buffers[writeBuffer].clear(); // new events go into this buffer which should be empty

            buffers[readBuffer].clear();  // clear read buffer in case this buffer was reset by resetTimestamps
//            log.info("buffers reset");

        }

        // allocates AEPacketRaw each with capacity AE_BUFFER_SIZE
        private void allocateMemory() {
            buffers = new AEPacketRaw[2];
            for (int i = 0; i < buffers.length; i++) {
                buffers[i] = new AEPacketRaw();
                buffers[i].ensureCapacity(getAEBufferSize()); // preallocate this memory for capture thread and to try to make it contiguous

            }
        }
    }
}