import java.io.*;
import java.util.TreeSet;
import java.util.Arrays;
import java.util.stream.Collectors;

/** Generated by Gemini from prompt "Write me a pair of java methods that 
 * export and import the following static class called "Marks" to human-readable CSV file.
 * The methods should take a File as input and the import method 
 * should also have an argument for the Marks instance to be populated."
 * 
 * @author tobid
 */
public class MarksCsvHandler {

    // Placeholder for AEFileInputStream.
    // In your actual application, this would be your defined class.
    public static class AEFileInputStream {
        public AEFileInputStream() {
            // Constructor for demonstration.
            // Add any necessary initialization here.
        }
    }

    /**
     * Represents a set of marks, including an 'in' mark, an 'out' mark,
     * and a collection of other specific marks.
     * Implements Serializable, though for CSV export/import, custom handling is used.
     */
    public static class Marks implements Serializable {
        // This field is marked 'transient' because it's not intended to be
        // serialized by Java's default serialization mechanism.
        // For CSV export/import, we explicitly ignore it.
        transient AEFileInputStream aeFileInputStream;

        /**
         * Constructs a Marks instance, typically associated with a file input stream.
         * @param aeFileInputStream The AEFileInputStream instance.
         */
        public Marks(AEFileInputStream aeFileInputStream) {
            this.aeFileInputStream = aeFileInputStream;
        }

        // Default values for markIn and markOut.
        public long markIn = 0;
        public long markOut = Long.MAX_VALUE;
        // A TreeSet is used to store other marks, ensuring they are unique and sorted.
        public TreeSet<Long> otherMarks = new TreeSet<>(); // Initialize to prevent NullPointerException

        /**
         * Provides a string representation of the Marks object for debugging.
         * @return A string detailing the markIn, markOut, and the count of otherMarks.
         */
        @Override
        public String toString() {
            return "Marks{" + "markIn=" + markIn + ", markOut=" + markOut + ", otherMarks: " + otherMarks.size() + " (" + otherMarks + ")}";
        }
    }

    /**
     * Exports the data from a given Marks instance to a specified CSV file.
     * The CSV file will have a header row and one data row.
     * The format is: markIn,markOut,"comma_separated_otherMarks"
     *
     * @param marks The Marks object whose data is to be exported.
     * @param file The File object representing the target CSV file.
     * @throws IOException If an I/O error occurs during file writing.
     */
    public static void exportMarksToCsv(Marks marks, File file) throws IOException {
        // Use try-with-resources to ensure the BufferedWriter is closed automatically.
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {
            // Write the header row for clarity in the CSV file.
            writer.write("markIn,markOut,otherMarks\n");

            // Convert the TreeSet of Longs into a single comma-separated string.
            // Each Long is mapped to its String representation, then joined.
            String otherMarksString = marks.otherMarks.stream()
                                            .map(String::valueOf)
                                            .collect(Collectors.joining(","));

            // Write the data row.
            // The 'otherMarksString' is enclosed in double quotes to handle potential
            // commas within the data itself, which is standard CSV practice.
            writer.write(String.format("%d,%d,\"%s\"\n",
                    marks.markIn,      // First column: markIn
                    marks.markOut,     // Second column: markOut
                    otherMarksString)); // Third column: otherMarks as a quoted string
        }
    }

    /**
     * Imports Marks data from a specified CSV file and populates the given Marks instance.
     * It expects the CSV file to have a header row (which is skipped) and then one data row.
     * The expected format is: markIn,markOut,"comma_separated_otherMarks"
     *
     * @param marks The Marks object to be populated with the imported data.
     * This object must not be null.
     * @param file The File object representing the source CSV file.
     * @throws IOException If an I/O error occurs during file reading.
     * @throws IllegalArgumentException If the provided Marks instance is null,
     * or if the CSV file format is unexpected (e.g., wrong number of columns,
     * invalid number format).
     */
    public static void importMarksFromCsv(Marks marks, File file) throws IOException, IllegalArgumentException {
        // Validate that the Marks instance to be populated is not null.
        if (marks == null) {
            throw new IllegalArgumentException("Marks instance to populate cannot be null.");
        }

        // Use try-with-resources to ensure the BufferedReader is closed automatically.
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            int lineNumber = 0;

            // Read and skip the header line.
            if ((line = reader.readLine()) != null) {
                lineNumber++; // Increment line number for the header.
                // In a more robust solution, you might parse the header to validate columns.
            } else {
                // If the file is empty (no header), throw an exception.
                throw new IOException("CSV file is empty or contains no header.");
            }

            // Read the actual data line.
            if ((line = reader.readLine()) != null) {
                lineNumber++; // Increment line number for the data.

                // Split the line by comma, but only if the comma is NOT inside double quotes.
                // This regex handles the quoted 'otherMarks' field correctly.
                String[] parts = line.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)");

                // Check if the number of parsed parts matches the expected number of columns.
                if (parts.length != 3) {
                    throw new IllegalArgumentException("Unexpected number of columns in CSV line " + lineNumber + ": " + line + ". Expected 3, found " + parts.length);
                }

                try {
                    // Parse markIn and markOut from the first two parts.
                    marks.markIn = Long.parseLong(parts[0].trim());
                    marks.markOut = Long.parseLong(parts[1].trim());

                    // Process the 'otherMarks' string.
                    String otherMarksCsv = parts[2].trim();
                    // Remove enclosing double quotes if they exist (from the export process).
                    if (otherMarksCsv.startsWith("\"") && otherMarksCsv.endsWith("\"")) {
                        otherMarksCsv = otherMarksCsv.substring(1, otherMarksCsv.length() - 1);
                    }

                    // Clear any existing marks in the TreeSet before adding new ones.
                    marks.otherMarks.clear();
                    // If the otherMarksCsv string is not empty, parse its contents.
                    if (!otherMarksCsv.isEmpty()) {
                        // Split the string by comma, trim each part, filter out empty strings,
                        // parse each part to a Long, and add it to the TreeSet.
                        Arrays.stream(otherMarksCsv.split(","))
                              .map(String::trim)
                              .filter(s -> !s.isEmpty()) // Filter out empty strings that might result from splitting (e.g., "1,,2")
                              .map(Long::parseLong)
                              .forEach(marks.otherMarks::add);
                    }
                } catch (NumberFormatException e) {
                    // Catch and re-throw NumberFormatException with more context.
                    throw new IllegalArgumentException("Invalid number format in CSV line " + lineNumber + ": " + line, e);
                }
            } else {
                // If there's only a header and no data, throw an exception.
                throw new IOException("CSV file contains only header, no data found.");
            }
        }
    }

    /**
     * Main method for demonstrating the export and import functionality.
     */
    public static void main(String[] args) {
        // --- Example Usage ---

        // 1. Create a sample Marks instance with some data.
        AEFileInputStream aeFis = new AEFileInputStream(); // Placeholder instance for demonstration
        Marks myMarks = new Marks(aeFis);
        myMarks.markIn = 12345;
        myMarks.markOut = 98765;
        myMarks.otherMarks.add(1000L);
        myMarks.otherMarks.add(5000L);
        myMarks.otherMarks.add(2500L); // TreeSet will automatically sort these
        myMarks.otherMarks.add(7500L);

        System.out.println("Original Marks: " + myMarks);

        // 2. Define the CSV file name.
        File csvFile = new File("marks_data_example.csv");

        // 3. Export the Marks instance to the CSV file.
        try {
            exportMarksToCsv(myMarks, csvFile);
            System.out.println("Marks exported successfully to: " + csvFile.getAbsolutePath());
        } catch (IOException e) {
            System.err.println("Error exporting marks: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for detailed error info
        }

        System.out.println("\n--- Attempting Import ---");

        // 4. Create a new, empty Marks instance to receive the imported data.
        Marks importedMarks = new Marks(new AEFileInputStream()); // New instance for import

        // 5. Import Marks data from the CSV file into the new instance.
        try {
            importMarksFromCsv(importedMarks, csvFile);
            System.out.println("Imported Marks: " + importedMarks);

            // 6. Verify if the imported data matches the original data.
            System.out.println("\nVerification:");
            System.out.println("markIn matches: " + (myMarks.markIn == importedMarks.markIn));
            System.out.println("markOut matches: " + (myMarks.markOut == importedMarks.markOut));
            System.out.println("otherMarks matches: " + myMarks.otherMarks.equals(importedMarks.otherMarks));

        } catch (IOException | IllegalArgumentException e) {
            System.err.println("Error importing marks: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for detailed error info
        }

        // Optional: Clean up the generated CSV file after demonstration.
        // if (csvFile.exists()) {
        //     if (csvFile.delete()) {
        //         System.out.println("\nCleaned up " + csvFile.getName());
        //     } else {
        //         System.err.println("\nFailed to delete " + csvFile.getName());
        //     }
        // }
    }
}
