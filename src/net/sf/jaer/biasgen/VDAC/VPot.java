/*
 * VPot.java
 *
 * Created on November 19, 2006, 9:19 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 *
 *
 *Copyright November 19, 2006 Tobi Delbruck, Inst. of Neuroinformatics, UNI-ETH Zurich
 */
package net.sf.jaer.biasgen.VDAC;

import javax.swing.JComponent;

import net.sf.jaer.biasgen.Pot;
import net.sf.jaer.chip.Chip;
import net.sf.jaer.util.RemoteControlCommand;
import net.sf.jaer.util.RemoteControlled;

/**
 * Describes a voltage bias, controlled by a voltage that is generated by a voltage DAC. Used for off-chip voltage DACs for older chips that
 * do not have integrated IPots. A DAC may have an internal reference voltage that results in clipping of the output values to Vdd. For example, if the DAC
 * is running on a 3.3V supply and uses an internal 2.5V reference and also has a gain-of-2 buffer its full scale output would be 5V, but of course the value
 * is clipped to 3.3V. 
 *
 * @author tobi
 */
public class VPot extends Pot implements RemoteControlled {

    /** the delta voltage to change by in increment and decrement methods */
    public static final float VOLTAGE_CHANGE_VALUE_VOLTS = 0.005f;
    private int channel = 0;
    private DAC dac = null;

    /** Creates a new instance of VPot and loads the preferred bit value.
     *@param name
     *@param dac the DAC on the board
     * @param channel the DAC channel for this bias
     *@param type (NORMAL, CASCODE)
     *@param sex Sex (N, P)
     * @param bitValue initial bitValue
     *@param displayPosition position in GUI from top (logical order)
     *@param tooltipString a String to display to user of GUI telling them what the pots does
     */
    public VPot(Chip chip, String name, DAC dac, int channel, Type type, Sex sex, int bitValue, int displayPosition, String tooltipString) {
        super(chip);
        setDac(dac);
        setNumBits(dac.getResolutionBits());
        setChannel(channel);
        setType(type);
        setSex(sex);
        this.bitValue = bitValue;
        this.displayPosition = displayPosition;
        this.tooltipString = tooltipString;
        setName(name);
        loadPreferences();
        if (chip.getRemoteControl()!=null){
            chip.getRemoteControl().addCommandListener(this, String.format("setv%s bitvalue",getName()), "Set the bitValue of VPot "+getName());
        }
    }

    /** sets the bit value based on desired voltage, clipped the DAC's Vdd or Vref.
     * Observers are notified if value changes.
     *@param voltage in volts
     *@return actual float value of voltage after resolution rounding and vdd clipping.
     */
    public float setVoltage(float voltage) {
        float maxVoltagePossible = Math.min(dac.getVdd(), dac.getRefMaxVolts());
        if (voltage > maxVoltagePossible) voltage = maxVoltagePossible;
        setBitValue(Math.round(voltage * getMaxBitValue() / dac.getRefMaxVolts()));
        return getVoltage();
    }

    public byte[] getByteRepresentation() {
        return null;
    }

    /** gets the voltage output by this VPot according the bit value times the difference between ref min and ref max, clipped
     * to the DAC's vdd.
     * @return voltage in volts.
     */
    public float getVoltage() {
        float v = getMinVoltage() + getVoltageResolution() * getBitValue();
        if (v > dac.getVdd()) v = dac.getVdd();
        return v;
    }

    /** @return max possible voltage */
    public float getMaxVoltage() {
        return getDac().getRefMaxVolts();
    }

    /** @return min possible voltage. */
    public float getMinVoltage() {
        return getDac().getRefMinVolts();
    }

    /** return resolution of pot in voltage.
     *@return smallest possible voltage change -- in principle.
     */
    public float getVoltageResolution() {
        return (getDac().getRefMaxVolts() - getDac().getRefMinVolts()) / ((1 << getNumBits()) - 1);
    }

    /** increment pot value  */
    public void incrementVoltage() {
        setVoltage(getVoltage() + VOLTAGE_CHANGE_VALUE_VOLTS);
    }

    /** decrement pot value  */
    public void decrementVoltage() {
        setVoltage(getVoltage() - VOLTAGE_CHANGE_VALUE_VOLTS);
    }

    public int getDacNumber() {
        return dac.getDacNumber();
    }

    public int getChannel() {
        return channel;
    }

    public void setChannel(int channel) {
        if (channel > dac.getNumChannels() - 1) {
            throw new RuntimeException("VPot channel " + channel + " higher than number of channels in DAC (" + dac.getNumChannels() + ")");
        }
        this.channel = channel;
    }

    public DAC getDac() {
        return dac;
    }

    public void setDac(DAC dac) {
        this.dac = dac;
    }

    public float getPhysicalValue() {
        return getVoltage();
    }

    public String getPhysicalValueUnits() {
        return "V";
    }

    public void setPhysicalValue(float value) {
        setVoltage(value);
    }

    public JComponent makeGUIPotControl() {
        return new VPotGUIControl(this);
    }

    /** changes VPot value by a fraction of full scale, e.g. -0.05f for a -5% decrease of full-scale value
     * @param fraction of full scale value
     */
    public void changeByFractionOfFullScale(float fraction) {
        int change = (int) (getMaxBitValue() * fraction);
        setBitValue(getBitValue() + change);
    }
    private byte[] bytes = null;

    /** Computes and returns a the reused array of bytes representing the bias to be sent over hardware interface to the device
    @return array of bytes to be sent, by convention values are ordered in big endian format so that byte 0 is the most significant byte and is sent first to the hardware
     */
    @Override
    public byte[] getBinaryRepresentation() {
        int n = getNumBytes();
        if (bytes == null) {
            bytes = new byte[n];
        }
        int val = getBitValue();
        int k = 0;
        for (int i = bytes.length - 1; i >= 0; i--) {
            bytes[k++] = (byte) (0xff & (val >>> (i * 8)));
        }
        return bytes;
    }

    /** Returns the String key by which this pot is known in the Preferences. For VPot's, this
    name is the Chip simple class name followed by VPot.<potName>, e.g. "Tmpdiff128.VPot.VRefAmp".
    @return preferences key
     */
    @Override
    protected String prefsKey() {
        return chip.getClass().getSimpleName() + ".VPot." + name;
    }

    public String processRemoteControlCommand(RemoteControlCommand command, String input) {
        String[] t = input.split("\\s");
        if (t.length < 2) {
            return "? " + this + "\n";
        } else {
            try {
                int bv = Integer.parseInt(t[1]);
                setBitValue(bv);
                return this + "\n";
            } catch (NumberFormatException e) {
                log.warning(input + " caused " + e);
                return e.toString() + "\n";
            }
        }
    }
}
